{"msg":[{"@type":"/vm.m_addpkg","creator":"g155vatadknr3gdq9pq6va8q4jk6gu4znklkjkce","package":{"name":"financial_trading","path":"gno.land/r/g155vatadknr3gdq9pq6va8q4jk6gu4znklkjkce/financial_trading","files":[{"name":"financial_trading.gno","body":"// Package financial_trading provides a deployable financial trading agent realm\n// for the Gno blockchain. This realm implements risk-aware automated trading\n// using Active Inference methods for market analysis and decision-making.\npackage financial_trading\n\nimport (\n    \"gno.land/p/active_inference/methods/active_inference_core\"\n    \"gno.land/p/active_inference/methods\"\n    \"std\"\n    \"gno.land/p/nt/ufmt\"\n    \"math\"\n)\n\n// =============================================================================\n// GLOBAL STATE - PERSISTED ACROSS TRANSACTIONS\n// =============================================================================\n\n// Core trading agent instance\nvar tradingAgent *active_inference_core.ActiveInferenceAgent\n\n// Access control\nvar owner string\nvar authorizedTraders []string\n\n// Trading history and analytics\nvar tradeHistory []TradeRecord\nvar positionHistory []PositionRecord\nvar marketDataHistory []MarketDataRecord\n\n// Performance metrics\nvar totalTrades int64\nvar successfulTrades int64\nvar totalProfitLoss methods.Probability\nvar riskMetrics RiskMetrics\n\n// Market state\nvar currentMarketState MarketState\nvar portfolioValue methods.Probability\n\n// =============================================================================\n// DATA STRUCTURES\n// =============================================================================\n\n// TradeRecord tracks individual trades\ntype TradeRecord struct {\n    Timestamp     int64\n    Symbol        string\n    Action        string  // \"BUY\", \"SELL\", \"HOLD\"\n    Quantity      methods.Probability\n    Price         methods.Probability\n    TotalValue    methods.Probability\n    Confidence    methods.Probability\n    RiskLevel     methods.Probability\n    GasUsed       uint64\n}\n\n// PositionRecord tracks portfolio positions\ntype PositionRecord struct {\n    Timestamp     int64\n    Symbol        string\n    Quantity      methods.Probability\n    AveragePrice  methods.Probability\n    CurrentPrice  methods.Probability\n    UnrealizedPnL methods.Probability\n    Allocation    methods.Probability\n}\n\n// MarketDataRecord tracks market data observations\ntype MarketDataRecord struct {\n    Timestamp   int64\n    Price       methods.Probability\n    Volume      methods.Probability\n    Volatility  methods.Probability\n    Sentiment   methods.Probability\n    Trend       methods.Probability\n}\n\n// RiskMetrics tracks risk management metrics\ntype RiskMetrics struct {\n    MaxDrawdown       methods.Probability\n    SharpeRatio       methods.Probability\n    Volatility        methods.Probability\n    VaR95             methods.Probability // Value at Risk 95%\n    MaxPositionSize   methods.Probability\n    DiversificationRatio methods.Probability\n}\n\n// MarketState represents current market conditions\ntype MarketState struct {\n    Trend       methods.Probability // Bullish (1.0) to Bearish (0.0)\n    Volatility  methods.Probability // Market volatility level\n    Sentiment   methods.Probability // Market sentiment (positive to negative)\n    Confidence  methods.Probability // Agent confidence in market state\n}\n\n// =============================================================================\n// REALM INITIALIZATION\n// =============================================================================\n\n// init is called when the realm is deployed to the blockchain\nfunc init() {\n    // Initialize trading agent\n    tradingAgent = active_inference_core.NewActiveInferenceAgent()\n\n    // Initialize access control\n    owner = \"\"\n    authorizedTraders = make([]string, 0)\n\n    // Initialize history arrays\n    tradeHistory = make([]TradeRecord, 0)\n    positionHistory = make([]PositionRecord, 0)\n    marketDataHistory = make([]MarketDataRecord, 0)\n\n    // Initialize metrics\n    totalTrades = 0\n    successfulTrades = 0\n    totalProfitLoss = 0\n    portfolioValue = 1000.0 // Starting portfolio value\n\n    // Initialize risk metrics\n    riskMetrics = RiskMetrics{\n        MaxDrawdown: 0,\n        SharpeRatio: 0,\n        Volatility: 0.2,\n        VaR95: 0.05,\n        MaxPositionSize: 0.25, // Max 25% of portfolio per position\n        DiversificationRatio: 0.7,\n    }\n\n    // Initialize market state\n    currentMarketState = MarketState{\n        Trend: 0.5,      // Neutral trend\n        Volatility: 0.2, // Moderate volatility\n        Sentiment: 0.5,  // Neutral sentiment\n        Confidence: 0.6, // Moderate confidence\n    }\n\n    ufmt.Printf(\"Financial trading agent realm initialized\\n\")\n}\n\n// =============================================================================\n// ACCESS CONTROL METHODS\n// =============================================================================\n\n// Deploy initializes the trading agent for a specific owner\nfunc Deploy(caller string, tradingOwner string) string {\n    if owner != \"\" {\n        return \"Trading agent already deployed\"\n    }\n\n    if !std.IsValidAddress(tradingOwner) {\n        return \"Invalid owner address\"\n    }\n\n    owner = tradingOwner\n\n    // Emit deployment event\n    std.Emit(\"TradingAgentDeployed\", map[string]interface{}{\n        \"owner\": tradingOwner,\n        \"timestamp\": std.BlockTime(),\n        \"agentType\": \"FinancialTradingAgent\",\n        \"initialPortfolio\": portfolioValue,\n    })\n\n    return \"Financial trading agent deployed successfully\"\n}\n\n// IsAuthorized checks if the caller is authorized to perform trading actions\nfunc IsAuthorized(caller string) bool {\n    return caller == owner\n}\n\n// AddAuthorizedTrader adds a trader to the authorized list\nfunc AddAuthorizedTrader(caller string, trader string) string {\n    if !IsAuthorized(caller) {\n        return \"Access denied: only owner can authorize traders\"\n    }\n\n    // Check if already authorized\n    for _, authorized := range authorizedTraders {\n        if authorized == trader {\n            return \"Trader already authorized\"\n        }\n    }\n\n    authorizedTraders = append(authorizedTraders, trader)\n\n    std.Emit(\"TraderAuthorized\", map[string]interface{}{\n        \"trader\": trader,\n        \"authorizedBy\": caller,\n        \"timestamp\": std.BlockTime(),\n    })\n\n    return \"Trader authorized successfully\"\n}\n\n// =============================================================================\n// MARKET DATA PROCESSING\n// =============================================================================\n\n// ProcessMarketData processes market data and makes trading decisions\nfunc ProcessMarketData(caller string, marketData []methods.Probability) string {\n    if !IsAuthorized(caller) {\n        return \"Access denied: not authorized to trade\"\n    }\n\n    // Validate market data length (price, volume, volatility, sentiment)\n    if len(marketData) != 4 {\n        return \"Invalid market data: expected 4 values (price, volume, volatility, sentiment)\"\n    }\n\n    // Record market data\n    marketRecord := MarketDataRecord{\n        Timestamp:  std.BlockTime(),\n        Price:      marketData[0],\n        Volume:     marketData[1],\n        Volatility: marketData[2],\n        Sentiment:  marketData[3],\n        Trend:      calculateTrend(marketData),\n    }\n    marketDataHistory = append(marketDataHistory, marketRecord)\n\n    // Update market state\n    updateMarketState(marketData)\n\n    // Process with trading agent\n    err := tradingAgent.Perceive(marketData)\n    if err != nil {\n        return \"Error processing market data: \" + err.Error()\n    }\n\n    // Generate trading decision\n    policies, err := tradingAgent.Plan()\n    if err != nil {\n        return \"Error generating trading plan: \" + err.Error()\n    }\n\n    // Execute trading decision\n    tradingAction := analyzeTradingSignal(policies)\n    result := executeTrade(caller, tradingAction, marketData)\n\n    return result\n}\n\n// calculateTrend computes market trend from recent data\nfunc calculateTrend(marketData []methods.Probability) methods.Probability {\n    if len(marketDataHistory) \u003c 2 {\n        return 0.5 // Neutral trend\n    }\n\n    // Simple trend calculation based on price momentum\n    currentPrice := marketData[0]\n    prevPrice := marketDataHistory[len(marketDataHistory)-1].Price\n\n    if currentPrice \u003e prevPrice {\n        return methods.Probability(math.Min(1.0, float64(currentPrice-prevPrice)*10))\n    } else {\n        return methods.Probability(math.Max(0.0, float64(prevPrice-currentPrice)*10))\n    }\n}\n\n// updateMarketState updates the current market state based on new data\nfunc updateMarketState(marketData []methods.Probability) {\n    // Update trend\n    currentMarketState.Trend = (currentMarketState.Trend*0.7 + calculateTrend(marketData)*0.3)\n\n    // Update volatility (exponential moving average)\n    currentMarketState.Volatility = (currentMarketState.Volatility*0.8 + marketData[2]*0.2)\n\n    // Update sentiment\n    currentMarketState.Sentiment = (currentMarketState.Sentiment*0.7 + marketData[3]*0.3)\n\n    // Update confidence based on data consistency\n    confidenceChange := methods.Probability(0.1) // Default confidence increase\n    if len(marketDataHistory) \u003e 1 {\n        prevData := marketDataHistory[len(marketDataHistory)-1]\n        consistency := methods.Probability(1.0)\n        if math.Abs(float64(marketData[0]-prevData.Price)) \u003e 0.1 {\n            consistency -= 0.3\n        }\n        confidenceChange = consistency * 0.05\n    }\n\n    currentMarketState.Confidence = methods.Probability(math.Min(1.0, math.Max(0.3, float64(currentMarketState.Confidence+confidenceChange))))\n}\n\n// analyzeTradingSignal analyzes trading policies and determines action\nfunc analyzeTradingSignal(policies []active_inference_core.Policy) string {\n    if len(policies) == 0 {\n        return \"HOLD\"\n    }\n\n    // Analyze first policy for trading signal\n    policy := policies[0]\n    if len(policy.Actions) == 0 {\n        return \"HOLD\"\n    }\n\n    // Simple decision based on policy confidence and market state\n    buySignal := policy.Actions[0] \u003e 0.6 \u0026\u0026 currentMarketState.Trend \u003e 0.6\n    sellSignal := policy.Actions[0] \u003c 0.4 \u0026\u0026 currentMarketState.Trend \u003c 0.4\n\n    if buySignal {\n        return \"BUY\"\n    } else if sellSignal {\n        return \"SELL\"\n    }\n\n    return \"HOLD\"\n}\n\n// executeTrade executes a trading decision\nfunc executeTrade(caller string, action string, marketData []methods.Probability) string {\n    if action == \"HOLD\" {\n        return \"No trading action required - market conditions stable\"\n    }\n\n    // Calculate trade parameters\n    price := marketData[0]\n    maxPositionSize := portfolioValue * riskMetrics.MaxPositionSize\n    tradeValue := maxPositionSize * methods.Probability(0.5) // Use 50% of max position\n\n    quantity := tradeValue / price\n\n    // Create trade record\n    trade := TradeRecord{\n        Timestamp:  std.BlockTime(),\n        Symbol:     \"GNO\", // Trading GNO tokens\n        Action:     action,\n        Quantity:   quantity,\n        Price:      price,\n        TotalValue: tradeValue,\n        Confidence: currentMarketState.Confidence,\n        RiskLevel:  calculateRiskLevel(action),\n        GasUsed:    std.GasUsed(),\n    }\n\n    tradeHistory = append(tradeHistory, trade)\n\n    // Update position\n    updatePosition(trade)\n\n    // Update performance metrics\n    updatePerformanceMetrics(trade)\n\n    // Update agent learning\n    reward := calculateTradeReward(trade)\n    err := tradingAgent.Learn(reward)\n    if err != nil {\n        return \"Trade executed but learning error: \" + err.Error()\n    }\n\n    // Emit trade event\n    std.Emit(\"TradeExecuted\", map[string]interface{}{\n        \"action\": action,\n        \"quantity\": quantity,\n        \"price\": price,\n        \"value\": tradeValue,\n        \"confidence\": currentMarketState.Confidence,\n        \"timestamp\": std.BlockTime(),\n    })\n\n    return ufmt.Sprintf(\"Trade executed: %s %.3f GNO at price %.3f (value: %.3f)\",\n        action, quantity, price, tradeValue)\n}\n\n// calculateRiskLevel calculates risk level for a trade\nfunc calculateRiskLevel(action string) methods.Probability {\n    baseRisk := currentMarketState.Volatility * 0.5\n\n    // Adjust risk based on action and market conditions\n    if action == \"BUY\" \u0026\u0026 currentMarketState.Trend \u003c 0.3 {\n        baseRisk += 0.2 // Higher risk for buying in bear market\n    } else if action == \"SELL\" \u0026\u0026 currentMarketState.Trend \u003e 0.7 {\n        baseRisk += 0.2 // Higher risk for selling in bull market\n    }\n\n    return methods.Probability(math.Min(1.0, float64(baseRisk)))\n}\n\n// updatePosition updates portfolio position after trade\nfunc updatePosition(trade TradeRecord) {\n    // Find existing position or create new one\n    positionIndex := -1\n    for i, pos := range positionHistory {\n        if pos.Symbol == trade.Symbol {\n            positionIndex = i\n            break\n        }\n    }\n\n    if positionIndex == -1 {\n        // Create new position\n        newPosition := PositionRecord{\n            Timestamp:    std.BlockTime(),\n            Symbol:       trade.Symbol,\n            Quantity:     0,\n            AveragePrice: 0,\n            CurrentPrice: trade.Price,\n            UnrealizedPnL: 0,\n            Allocation:   0,\n        }\n        positionHistory = append(positionHistory, newPosition)\n        positionIndex = len(positionHistory) - 1\n    }\n\n    position := \u0026positionHistory[positionIndex]\n\n    if trade.Action == \"BUY\" {\n        // Update average price\n        totalValue := position.Quantity*position.AveragePrice + trade.Quantity*trade.Price\n        position.Quantity += trade.Quantity\n        position.AveragePrice = totalValue / position.Quantity\n    } else if trade.Action == \"SELL\" {\n        position.Quantity -= trade.Quantity\n        if position.Quantity \u003c= 0 {\n            // Remove position if fully sold\n            positionHistory = append(positionHistory[:positionIndex], positionHistory[positionIndex+1:]...)\n            return\n        }\n    }\n\n    position.CurrentPrice = trade.Price\n    position.Timestamp = std.BlockTime()\n\n    // Calculate unrealized P\u0026L\n    position.UnrealizedPnL = (trade.Price - position.AveragePrice) * position.Quantity\n\n    // Update allocation\n    position.Allocation = (position.Quantity * trade.Price) / portfolioValue\n}\n\n// updatePerformanceMetrics updates trading performance metrics\nfunc updatePerformanceMetrics(trade TradeRecord) {\n    totalTrades++\n\n    // Update P\u0026L\n    if trade.Action == \"BUY\" {\n        totalProfitLoss -= trade.TotalValue\n    } else if trade.Action == \"SELL\" {\n        totalProfitLoss += trade.TotalValue\n    }\n\n    // Track successful trades (simplified)\n    if trade.Confidence \u003e 0.6 {\n        successfulTrades++\n    }\n\n    // Update risk metrics\n    updateRiskMetrics(trade)\n}\n\n// updateRiskMetrics updates risk management metrics\nfunc updateRiskMetrics(trade TradeRecord) {\n    // Update volatility estimate\n    riskMetrics.Volatility = (riskMetrics.Volatility*0.9 + trade.RiskLevel*0.1)\n\n    // Update max drawdown (simplified)\n    currentValue := portfolioValue + totalProfitLoss\n    if currentValue \u003c portfolioValue {\n        drawdown := (portfolioValue - currentValue) / portfolioValue\n        if drawdown \u003e riskMetrics.MaxDrawdown {\n            riskMetrics.MaxDrawdown = drawdown\n        }\n    }\n\n    // Update Sharpe ratio (simplified)\n    if totalTrades \u003e 0 {\n        winRate := methods.Probability(successfulTrades) / methods.Probability(totalTrades)\n        riskMetrics.SharpeRatio = (winRate - 0.5) / riskMetrics.Volatility\n    }\n}\n\n// calculateTradeReward calculates reward for agent learning\nfunc calculateTradeReward(trade TradeRecord) methods.Probability {\n    // Simplified reward calculation\n    baseReward := methods.Probability(0.0)\n\n    if trade.Action == \"BUY\" \u0026\u0026 currentMarketState.Trend \u003e 0.6 {\n        baseReward += 0.1 // Positive reward for buying in bull market\n    } else if trade.Action == \"SELL\" \u0026\u0026 currentMarketState.Trend \u003c 0.4 {\n        baseReward += 0.1 // Positive reward for selling in bear market\n    }\n\n    // Risk-adjusted reward\n    riskAdjustment := methods.Probability(1.0) - trade.RiskLevel\n    return baseReward * riskAdjustment\n}\n\n// =============================================================================\n// QUERY METHODS\n// =============================================================================\n\n// GetTradingStatus returns current trading agent status\nfunc GetTradingStatus(caller string) string {\n    if !IsAuthorized(caller) {\n        return \"Access denied\"\n    }\n\n    return ufmt.Sprintf(`Financial Trading Agent Status:\nOwner: %s\nPortfolio Value: %.2f\nTotal Trades: %d\nSuccessful Trades: %d\nSuccess Rate: %.1f%%\nTotal P\u0026L: %.2f\nCurrent Market State:\n  Trend: %.3f\n  Volatility: %.3f\n  Sentiment: %.3f\n  Confidence: %.3f\nRisk Metrics:\n  Max Drawdown: %.3f\n  Sharpe Ratio: %.3f\n  VaR 95%%: %.3f\nBlock Height: %d`,\n        owner, portfolioValue, totalTrades, successfulTrades,\n        float64(successfulTrades)/float64(totalTrades)*100, totalProfitLoss,\n        currentMarketState.Trend, currentMarketState.Volatility,\n        currentMarketState.Sentiment, currentMarketState.Confidence,\n        riskMetrics.MaxDrawdown, riskMetrics.SharpeRatio, riskMetrics.VaR95,\n        std.BlockHeight())\n}\n\n// GetTradeHistory returns recent trading history\nfunc GetTradeHistory(caller string) string {\n    if !IsAuthorized(caller) {\n        return \"Access denied\"\n    }\n\n    if len(tradeHistory) == 0 {\n        return \"No trading history available\"\n    }\n\n    history := \"Recent Trading History:\\n\"\n    maxHistory := 10\n    if len(tradeHistory) \u003c maxHistory {\n        maxHistory = len(tradeHistory)\n    }\n\n    for i := len(tradeHistory) - maxHistory; i \u003c len(tradeHistory); i++ {\n        trade := tradeHistory[i]\n        history += ufmt.Sprintf(\"Trade %d: %s %.3f @ %.3f (Conf: %.2f, Risk: %.2f)\\n\",\n            i+1, trade.Action, trade.Quantity, trade.Price, trade.Confidence, trade.RiskLevel)\n    }\n\n    return history\n}\n\n// GetPositionSummary returns current portfolio positions\nfunc GetPositionSummary(caller string) string {\n    if !IsAuthorized(caller) {\n        return \"Access denied\"\n    }\n\n    if len(positionHistory) == 0 {\n        return \"No positions in portfolio\"\n    }\n\n    summary := \"Current Portfolio Positions:\\n\"\n    for _, position := range positionHistory {\n        summary += ufmt.Sprintf(\"%s: %.3f shares @ avg %.3f (P\u0026L: %.2f, Alloc: %.1f%%)\\n\",\n            position.Symbol, position.Quantity, position.AveragePrice,\n            position.UnrealizedPnL, position.Allocation*100)\n    }\n\n    return summary\n}\n\n// GetMarketAnalysis returns current market analysis\nfunc GetMarketAnalysis(caller string) string {\n    if !IsAuthorized(caller) {\n        return \"Access denied\"\n    }\n\n    return ufmt.Sprintf(`Market Analysis:\nCurrent State:\n  Trend: %.3f (%s)\n  Volatility: %.3f (%s)\n  Sentiment: %.3f (%s)\n  Agent Confidence: %.3f\nRecent Data Points: %d\nRisk Assessment: %.3f\nTrading Signal: %s`,\n        currentMarketState.Trend,\n        getTrendDescription(currentMarketState.Trend),\n        currentMarketState.Volatility,\n        getVolatilityDescription(currentMarketState.Volatility),\n        currentMarketState.Sentiment,\n        getSentimentDescription(currentMarketState.Sentiment),\n        currentMarketState.Confidence,\n        len(marketDataHistory),\n        riskMetrics.VaR95,\n        getTradingSignal())\n}\n\n// Helper functions for descriptions\nfunc getTrendDescription(trend methods.Probability) string {\n    if trend \u003e 0.7 {\n        return \"Strongly Bullish\"\n    } else if trend \u003e 0.5 {\n        return \"Bullish\"\n    } else if trend \u003e 0.3 {\n        return \"Bearish\"\n    } else {\n        return \"Strongly Bearish\"\n    }\n}\n\nfunc getVolatilityDescription(vol methods.Probability) string {\n    if vol \u003c 0.1 {\n        return \"Very Low\"\n    } else if vol \u003c 0.2 {\n        return \"Low\"\n    } else if vol \u003c 0.3 {\n        return \"Moderate\"\n    } else {\n        return \"High\"\n    }\n}\n\nfunc getSentimentDescription(sentiment methods.Probability) string {\n    if sentiment \u003e 0.7 {\n        return \"Very Positive\"\n    } else if sentiment \u003e 0.5 {\n        return \"Positive\"\n    } else if sentiment \u003e 0.3 {\n        return \"Negative\"\n    } else {\n        return \"Very Negative\"\n    }\n}\n\nfunc getTradingSignal() string {\n    buySignal := currentMarketState.Trend \u003e 0.6 \u0026\u0026 currentMarketState.Confidence \u003e 0.6\n    sellSignal := currentMarketState.Trend \u003c 0.4 \u0026\u0026 currentMarketState.Confidence \u003e 0.6\n\n    if buySignal {\n        return \"BUY\"\n    } else if sellSignal {\n        return \"SELL\"\n    } else {\n        return \"HOLD\"\n    }\n}\n\n// =============================================================================\n// RENDER METHOD FOR REALM QUERIES\n// =============================================================================\n\n// Render provides string representation for queries\nfunc Render(path string) string {\n    switch path {\n    case \"\":\n        return GetTradingStatus(\"\")\n    case \"status\":\n        return GetTradingStatus(\"\")\n    case \"trades\":\n        return GetTradeHistory(\"\")\n    case \"positions\":\n        return GetPositionSummary(\"\")\n    case \"market\":\n        return GetMarketAnalysis(\"\")\n    default:\n        return \"Unknown path: \" + path\n    }\n}\n"},{"name":"gno.mod","body":"module gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/financial_trading\n\ngno 0.9\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"},"info":null},"send":""}],"fee":{"gas_wanted":"10000000","gas_fee":"10000000ugnot"},"signatures":null,"memo":""}
