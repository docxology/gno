{"msg":[{"@type":"/vm.m_addpkg","creator":"g155vatadknr3gdq9pq6va8q4jk6gu4znklkjkce","package":{"name":"multi_agent_system","path":"gno.land/r/g155vatadknr3gdq9pq6va8q4jk6gu4znklkjkce/multi_agent_system","files":[{"name":"gno.mod","body":"module gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/multi_agent_system\n\ngno 0.9\n"},{"name":"multi_agent_system.gno","body":"// Package multi_agent_system provides a deployable multi-agent coordination realm\n// for the Gno blockchain. This realm implements coordination between multiple\n// cognitive agents with social learning and consensus formation capabilities.\npackage multi_agent_system\n\nimport (\n    \"gno.land/p/active_inference/methods/active_inference_core\"\n    \"gno.land/p/active_inference/methods\"\n    \"std\"\n    \"gno.land/p/nt/ufmt\"\n)\n\n// =============================================================================\n// GLOBAL STATE - PERSISTED ACROSS TRANSACTIONS\n// =============================================================================\n\n// Core multi-agent system instance\nvar coordinator *active_inference_core.MultiAgentSystem\n\n// Access control\nvar systemOwner string\nvar registeredAgents map[string]bool\n\n// Coordination history and analytics\nvar coordinationHistory []CoordinationRecord\nvar agentConnections map[string][]string\nvar collectiveBeliefs []methods.Probability\n\n// Performance metrics\nvar totalCoordinationRounds int64\nvar averageConsensusLevel methods.Probability\nvar systemGasUsed uint64\n\n// =============================================================================\n// DATA STRUCTURES\n// =============================================================================\n\n// CoordinationRecord tracks coordination rounds and outcomes\ntype CoordinationRecord struct {\n    Timestamp      int64\n    AgentsActive   int\n    CollectiveBelief methods.Probability\n    ConsensusLevel methods.Probability\n    CoordinationOutcome string\n    GasUsed        uint64\n}\n\n// AgentRegistration records agent registration information\ntype AgentRegistration struct {\n    AgentID     string\n    Timestamp   int64\n    InitialBeliefs []methods.Probability\n    Capabilities []string\n    Status      string\n}\n\n// =============================================================================\n// REALM INITIALIZATION\n// =============================================================================\n\n// init is called when the realm is deployed to the blockchain\nfunc init() {\n    coordinator = active_inference_core.NewMultiAgentSystem(0) // Start with no agents\n    registeredAgents = make(map[string]bool)\n    agentConnections = make(map[string][]string)\n    coordinationHistory = make([]CoordinationRecord, 0)\n    collectiveBeliefs = make([]methods.Probability, 0)\n\n    // Initialize metrics\n    totalCoordinationRounds = 0\n    averageConsensusLevel = 0.5\n    systemGasUsed = 0\n    systemOwner = \"\"\n\n    ufmt.Printf(\"Multi-agent coordination realm initialized\\n\")\n}\n\n// =============================================================================\n// ACCESS CONTROL METHODS\n// =============================================================================\n\n// Deploy initializes the multi-agent system for a specific owner\nfunc Deploy(caller string, owner string) string {\n    if systemOwner != \"\" {\n        return \"Multi-agent system already deployed\"\n    }\n\n    if !std.IsValidAddress(owner) {\n        return \"Invalid owner address\"\n    }\n\n    systemOwner = owner\n\n    // Emit deployment event\n    std.Emit(\"MultiAgentSystemDeployed\", map[string]interface{}{\n        \"owner\": owner,\n        \"timestamp\": std.BlockTime(),\n        \"systemType\": \"ActiveInferenceCoordination\",\n    })\n\n    return \"Multi-agent coordination system deployed successfully\"\n}\n\n// IsAuthorized checks if the caller is authorized to perform actions\nfunc IsAuthorized(caller string) bool {\n    return caller == systemOwner || registeredAgents[caller]\n}\n\n// =============================================================================\n// AGENT MANAGEMENT METHODS\n// =============================================================================\n\n// RegisterAgent adds a new agent to the coordination system\nfunc RegisterAgent(caller string, agentID string) string {\n    if !IsAuthorized(caller) {\n        return \"Access denied: not authorized\"\n    }\n\n    if registeredAgents[agentID] {\n        return \"Agent already registered\"\n    }\n\n    // Create new active inference agent\n    newAgent := active_inference_core.NewActiveInferenceAgent()\n    coordinator.Agents = append(coordinator.Agents, newAgent)\n    registeredAgents[agentID] = true\n\n    // Initialize agent with default goals\n    newAgent.GoalSystem.SetGoal(0, methods.Probability(0.5))\n\n    // Set up social connections (fully connected by default)\n    agentConnections[agentID] = make([]string, 0)\n    for existingAgent := range registeredAgents {\n        if existingAgent != agentID {\n            agentConnections[agentID] = append(agentConnections[agentID], existingAgent)\n            agentConnections[existingAgent] = append(agentConnections[existingAgent], agentID)\n        }\n    }\n\n    // Update social graph in coordinator\n    coordinator.SocialGraph = agentConnections\n\n    // Record registration\n    registration := AgentRegistration{\n        AgentID:     agentID,\n        Timestamp:   std.BlockTime(),\n        InitialBeliefs: newAgent.CurrentBeliefs,\n        Capabilities: []string{\"perception\", \"planning\", \"action\", \"learning\"},\n        Status:      \"active\",\n    }\n\n    // Emit registration event\n    std.Emit(\"AgentRegistered\", map[string]interface{}{\n        \"agentID\": agentID,\n        \"totalAgents\": len(coordinator.Agents),\n        \"registration\": registration,\n        \"timestamp\": std.BlockTime(),\n    })\n\n    return ufmt.Sprintf(\"Agent %s registered successfully. Total agents: %d\",\n        agentID, len(coordinator.Agents))\n}\n\n// GetRegisteredAgents returns list of registered agent IDs\nfunc GetRegisteredAgents(caller string) string {\n    if !IsAuthorized(caller) {\n        return \"Access denied\"\n    }\n\n    if len(registeredAgents) == 0 {\n        return \"No agents registered\"\n    }\n\n    result := \"Registered Agents:\\n\"\n    for agentID := range registeredAgents {\n        result += ufmt.Sprintf(\"- %s\\n\", agentID)\n    }\n\n    return result\n}\n\n// =============================================================================\n// COORDINATION METHODS\n// =============================================================================\n\n// CoordinateRound executes one coordination round with shared observation\nfunc CoordinateRound(caller string, sharedObservation []methods.Probability) string {\n    if !IsAuthorized(caller) {\n        return \"Access denied\"\n    }\n\n    if len(coordinator.Agents) \u003c 2 {\n        return \"Need at least 2 agents for coordination\"\n    }\n\n    // Each agent processes the shared observation\n    for i, agent := range coordinator.Agents {\n        err := agent.Perceive(sharedObservation)\n        if err != nil {\n            return ufmt.Sprintf(\"Agent %d perception error: %s\", i, err.Error())\n        }\n\n        // Set individual goals (slightly different for diversity)\n        agent.GoalSystem.SetGoal(0, methods.Probability(0.5 + 0.1*methods.Probability(i)))\n        agent.Plan()\n        agent.Act(0)\n    }\n\n    // Coordinate agents\n    err := coordinator.CoordinateAgents()\n    if err != nil {\n        return \"Coordination error: \" + err.Error()\n    }\n\n    // Calculate collective metrics\n    totalBelief := methods.Probability(0)\n    for _, agent := range coordinator.Agents {\n        if len(agent.CurrentBeliefs) \u003e 0 {\n            totalBelief += agent.CurrentBeliefs[0] // Use first belief dimension\n        }\n    }\n    collectiveBelief := totalBelief / methods.Probability(len(coordinator.Agents))\n\n    // Calculate consensus level (inverse of belief variance)\n    variance := methods.Probability(0)\n    for _, agent := range coordinator.Agents {\n        if len(agent.CurrentBeliefs) \u003e 0 {\n            diff := agent.CurrentBeliefs[0] - collectiveBelief\n            variance += diff * diff\n        }\n    }\n    if len(coordinator.Agents) \u003e 0 {\n        variance /= methods.Probability(len(coordinator.Agents))\n    }\n    consensusLevel := methods.Probability(1.0) / (methods.Probability(1.0) + variance)\n\n    // Determine coordination outcome\n    outcome := \"partial_consensus\"\n    if consensusLevel \u003e 0.8 {\n        outcome = \"strong_consensus\"\n    } else if consensusLevel \u003c 0.3 {\n        outcome = \"divergence_detected\"\n    }\n\n    // Record coordination\n    record := CoordinationRecord{\n        Timestamp:       std.BlockTime(),\n        AgentsActive:    len(coordinator.Agents),\n        CollectiveBelief: collectiveBelief,\n        ConsensusLevel:  consensusLevel,\n        CoordinationOutcome: outcome,\n        GasUsed:         std.GasUsed(),\n    }\n    coordinationHistory = append(coordinationHistory, record)\n\n    // Update metrics\n    totalCoordinationRounds++\n    averageConsensusLevel = (averageConsensusLevel*methods.Probability(totalCoordinationRounds-1) + consensusLevel) / methods.Probability(totalCoordinationRounds)\n\n    // Store collective belief\n    collectiveBeliefs = append(collectiveBeliefs, collectiveBelief)\n\n    // Emit coordination event\n    std.Emit(\"CoordinationCompleted\", map[string]interface{}{\n        \"roundNumber\": totalCoordinationRounds,\n        \"agents\": len(coordinator.Agents),\n        \"collectiveBelief\": collectiveBelief,\n        \"consensusLevel\": consensusLevel,\n        \"outcome\": outcome,\n        \"timestamp\": std.BlockTime(),\n    })\n\n    return ufmt.Sprintf(`Coordination Round %d Completed:\nAgents Active: %d\nCollective Belief: %.3f\nConsensus Level: %.3f\nOutcome: %s\nObservation Dimensions: %d`,\n        totalCoordinationRounds, len(coordinator.Agents), collectiveBelief,\n        consensusLevel, outcome, len(sharedObservation))\n}\n\n// =============================================================================\n// QUERY METHODS\n// =============================================================================\n\n// GetCoordinationHistory returns coordination history\nfunc GetCoordinationHistory(caller string) string {\n    if !IsAuthorized(caller) {\n        return \"Access denied\"\n    }\n\n    if len(coordinationHistory) == 0 {\n        return \"No coordination history available\"\n    }\n\n    history := \"Coordination History:\\n\"\n    for i, record := range coordinationHistory {\n        history += ufmt.Sprintf(`Round %d (Time: %d):\n  Agents: %d\n  Collective Belief: %.3f\n  Consensus Level: %.3f\n  Outcome: %s\n\n`,\n            i+1, record.Timestamp, record.AgentsActive,\n            record.CollectiveBelief, record.ConsensusLevel, record.CoordinationOutcome)\n    }\n\n    return history\n}\n\n// GetSystemStatus returns current system status\nfunc GetSystemStatus(caller string) string {\n    if !IsAuthorized(caller) {\n        return \"Access denied\"\n    }\n\n    latestConsensus := methods.Probability(0)\n    if len(coordinationHistory) \u003e 0 {\n        latestConsensus = coordinationHistory[len(coordinationHistory)-1].ConsensusLevel\n    }\n\n    return ufmt.Sprintf(`Multi-Agent System Status:\nOwner: %s\nTotal Agents: %d\nRegistered Agents: %d\nCoordination Rounds: %d\nAverage Consensus Level: %.3f\nLatest Consensus: %.3f\nSystem Gas Used: %d\nBlock Height: %d`,\n        systemOwner, len(coordinator.Agents), len(registeredAgents),\n        totalCoordinationRounds, averageConsensusLevel, latestConsensus,\n        systemGasUsed, std.BlockHeight())\n}\n\n// GetAgentBeliefs returns current beliefs of all agents\nfunc GetAgentBeliefs(caller string) string {\n    if !IsAuthorized(caller) {\n        return \"Access denied\"\n    }\n\n    if len(coordinator.Agents) == 0 {\n        return \"No agents available\"\n    }\n\n    result := \"Current Agent Beliefs:\\n\"\n    for i, agent := range coordinator.Agents {\n        result += ufmt.Sprintf(\"Agent %d: [\", i)\n        for j, belief := range agent.CurrentBeliefs {\n            if j \u003e 0 {\n                result += \", \"\n            }\n            result += ufmt.Sprintf(\"%.3f\", belief)\n        }\n        result += \"]\\n\"\n    }\n\n    return result\n}\n\n// =============================================================================\n// RENDER METHOD FOR REALM QUERIES\n// =============================================================================\n\n// Render provides string representation for queries\nfunc Render(path string) string {\n    switch path {\n    case \"\":\n        return GetSystemStatus(\"\")\n    case \"status\":\n        return GetSystemStatus(\"\")\n    case \"agents\":\n        return GetRegisteredAgents(\"\")\n    case \"beliefs\":\n        return GetAgentBeliefs(\"\")\n    case \"history\":\n        return GetCoordinationHistory(\"\")\n    default:\n        return \"Unknown path: \" + path\n    }\n}\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"},"info":null},"send":""}],"fee":{"gas_wanted":"10000000","gas_fee":"10000000ugnot"},"signatures":null,"memo":""}
