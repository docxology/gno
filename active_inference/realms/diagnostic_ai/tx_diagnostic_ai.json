{"msg":[{"@type":"/vm.m_addpkg","creator":"g155vatadknr3gdq9pq6va8q4jk6gu4znklkjkce","package":{"name":"diagnostic_ai","path":"gno.land/r/g155vatadknr3gdq9pq6va8q4jk6gu4znklkjkce/diagnostic_ai","files":[{"name":"diagnostic_ai.gno","body":"// Package diagnostic_ai provides an AI-powered medical diagnosis realm\n// using Bayesian networks for probabilistic medical reasoning\npackage diagnostic_ai\n\nimport (\n    \"gno.land/p/active_inference/methods/bayesian_inference\"\n    \"gno.land/p/active_inference/methods\"\n    \"std\"\n    \"gno.land/p/nt/ufmt\"\n    \"math\"\n)\n\n// =============================================================================\n// GLOBAL STATE - PERSISTED ACROSS TRANSACTIONS\n// =============================================================================\n\n// Core diagnostic system\nvar diagnosticNetwork *bayesian_inference.BayesianNetwork\nvar inferenceEngine *bayesian_inference.VariableElimination\n\n// Access control\nvar systemOwner string\nvar authorizedDoctors []string\n\n// Diagnosis history and analytics\nvar diagnosisHistory []DiagnosisCase\nvar systemMetrics SystemMetrics\n\n// Configuration\nvar confidenceThreshold methods.Probability\nvar maxHistorySize int\nvar totalGasUsed uint64\n\n// =============================================================================\n// DATA STRUCTURES\n// =============================================================================\n\n// DiagnosisCase represents a complete diagnostic assessment\ntype DiagnosisCase struct {\n    PatientID          string\n    Timestamp          int64\n    Symptoms           map[string]bool\n    TestResults        map[string]float64\n    Diagnosis          map[string]methods.Probability\n    Confidence         methods.Probability\n    RecommendedTests   []string\n    DoctorID           string\n    GasUsed           uint64\n    ProcessingTime    int64\n}\n\n// SystemMetrics tracks overall system performance\ntype SystemMetrics struct {\n    TotalDiagnoses     int64\n    AverageConfidence  methods.Probability\n    MostCommonDisease  string\n    AverageGasPerCase  uint64\n    LastUpdateTime     int64\n}\n\n// TestRecommendation represents a recommended diagnostic test\ntype TestRecommendation struct {\n    TestName     string\n    Priority     int    // 1=low, 2=medium, 3=high\n    Rationale    string\n    EstimatedCost float64\n}\n\n// =============================================================================\n// REALM INITIALIZATION\n// =============================================================================\n\n// init initializes the diagnostic AI system\nfunc init() {\n    // Initialize Bayesian network\n    diagnosticNetwork = createMedicalBayesianNetwork()\n\n    // Initialize inference engine\n    var err error\n    inferenceEngine, err = bayesian_inference.NewVariableElimination(diagnosticNetwork)\n    if err != nil {\n        panic(\"Failed to initialize inference engine: \" + err.Error())\n    }\n\n    // Initialize access control\n    systemOwner = \"\"\n    authorizedDoctors = make([]string, 0)\n\n    // Initialize history and metrics\n    diagnosisHistory = make([]DiagnosisCase, 0)\n    systemMetrics = SystemMetrics{\n        TotalDiagnoses:     0,\n        AverageConfidence:  0.0,\n        MostCommonDisease:  \"None\",\n        AverageGasPerCase:  0,\n        LastUpdateTime:     std.BlockTime(),\n    }\n\n    // Set configuration\n    confidenceThreshold = 0.7\n    maxHistorySize = 1000\n\n    // Emit initialization event\n    std.Emit(\"DiagnosticSystemInitialized\", map[string]interface{}{\n        \"timestamp\": std.BlockTime(),\n        \"networkNodes\": len(diagnosticNetwork.Nodes),\n        \"confidenceThreshold\": confidenceThreshold,\n    })\n}\n\n// createMedicalBayesianNetwork initializes the medical diagnostic network\nfunc createMedicalBayesianNetwork() *bayesian_inference.BayesianNetwork {\n    network := bayesian_inference.NewBayesianNetwork()\n\n    // Define diseases\n    flu := bayesian_inference.NewNode(\"Flu\", []string{\"yes\", \"no\"})\n    cold := bayesian_inference.NewNode(\"Cold\", []string{\"yes\", \"no\"})\n    pneumonia := bayesian_inference.NewNode(\"Pneumonia\", []string{\"yes\", \"no\"})\n    allergy := bayesian_inference.NewNode(\"Allergy\", []string{\"yes\", \"no\"})\n    covid := bayesian_inference.NewNode(\"COVID\", []string{\"yes\", \"no\"})\n\n    // Define symptoms\n    fever := bayesian_inference.NewNode(\"Fever\", []string{\"high\", \"moderate\", \"none\"})\n    cough := bayesian_inference.NewNode(\"Cough\", []string{\"severe\", \"mild\", \"none\"})\n    fatigue := bayesian_inference.NewNode(\"Fatigue\", []string{\"severe\", \"mild\", \"none\"})\n    headache := bayesian_inference.NewNode(\"Headache\", []string{\"severe\", \"mild\", \"none\"})\n    soreThroat := bayesian_inference.NewNode(\"SoreThroat\", []string{\"yes\", \"no\"})\n    shortnessOfBreath := bayesian_inference.NewNode(\"ShortnessOfBreath\", []string{\"yes\", \"no\"})\n    lossOfTaste := bayesian_inference.NewNode(\"LossOfTaste\", []string{\"yes\", \"no\"})\n\n    // Set up causal relationships\n    fever.AddParent(flu)\n    fever.AddParent(pneumonia)\n    fever.AddParent(covid)\n\n    cough.AddParent(flu)\n    cough.AddParent(cold)\n    cough.AddParent(covid)\n\n    fatigue.AddParent(flu)\n    fatigue.AddParent(pneumonia)\n    fatigue.AddParent(covid)\n\n    headache.AddParent(flu)\n    headache.AddParent(cold)\n    headache.AddParent(covid)\n\n    soreThroat.AddParent(flu)\n    soreThroat.AddParent(cold)\n\n    shortnessOfBreath.AddParent(pneumonia)\n    shortnessOfBreath.AddParent(covid)\n\n    lossOfTaste.AddParent(covid)\n\n    // Add nodes to network\n    network.AddNode(flu)\n    network.AddNode(cold)\n    network.AddNode(pneumonia)\n    network.AddNode(allergy)\n    network.AddNode(covid)\n    network.AddNode(fever)\n    network.AddNode(cough)\n    network.AddNode(fatigue)\n    network.AddNode(headache)\n    network.AddNode(soreThroat)\n    network.AddNode(shortnessOfBreath)\n    network.AddNode(lossOfTaste)\n\n    // Set conditional probability tables\n    setupMedicalCPTs(network)\n\n    return network\n}\n\n// setupMedicalCPTs configures conditional probability tables\nfunc setupMedicalCPTs(network *bayesian_inference.BayesianNetwork) {\n    // Prior probabilities for diseases (based on general population incidence)\n    network.GetNode(\"Flu\").SetCPT(\"\", []methods.Probability{0.06, 0.94})        // 6% flu incidence\n    network.GetNode(\"Cold\").SetCPT(\"\", []methods.Probability{0.12, 0.88})       // 12% cold incidence\n    network.GetNode(\"Pneumonia\").SetCPT(\"\", []methods.Probability{0.02, 0.98})  // 2% pneumonia incidence\n    network.GetNode(\"Allergy\").SetCPT(\"\", []methods.Probability{0.15, 0.85})    // 15% allergy incidence\n    network.GetNode(\"COVID\").SetCPT(\"\", []methods.Probability{0.08, 0.92})     // 8% COVID incidence\n\n    // Conditional probabilities for symptoms given diseases\n    // Fever | Diseases\n    network.GetNode(\"Fever\").SetCPT(\"Flu=yes,Pneumonia=yes,COVID=yes\", []methods.Probability{0.9, 0.08, 0.02})\n    network.GetNode(\"Fever\").SetCPT(\"Flu=yes,Pneumonia=yes,COVID=no\", []methods.Probability{0.8, 0.15, 0.05})\n    network.GetNode(\"Fever\").SetCPT(\"Flu=yes,Pneumonia=no,COVID=yes\", []methods.Probability{0.85, 0.1, 0.05})\n    network.GetNode(\"Fever\").SetCPT(\"Flu=yes,Pneumonia=no,COVID=no\", []methods.Probability{0.6, 0.3, 0.1})\n    network.GetNode(\"Fever\").SetCPT(\"Flu=no,Pneumonia=yes,COVID=yes\", []methods.Probability{0.9, 0.08, 0.02})\n    network.GetNode(\"Fever\").SetCPT(\"Flu=no,Pneumonia=yes,COVID=no\", []methods.Probability{0.75, 0.2, 0.05})\n    network.GetNode(\"Fever\").SetCPT(\"Flu=no,Pneumonia=no,COVID=yes\", []methods.Probability{0.7, 0.25, 0.05})\n    network.GetNode(\"Fever\").SetCPT(\"Flu=no,Pneumonia=no,COVID=no\", []methods.Probability{0.05, 0.15, 0.8})\n\n    // Cough | Diseases\n    network.GetNode(\"Cough\").SetCPT(\"Flu=yes,Cold=yes,COVID=yes\", []methods.Probability{0.95, 0.04, 0.01})\n    network.GetNode(\"Cough\").SetCPT(\"Flu=yes,Cold=yes,COVID=no\", []methods.Probability{0.85, 0.12, 0.03})\n    network.GetNode(\"Cough\").SetCPT(\"Flu=yes,Cold=no,COVID=yes\", []methods.Probability{0.9, 0.08, 0.02})\n    network.GetNode(\"Cough\").SetCPT(\"Flu=yes,Cold=no,COVID=no\", []methods.Probability{0.7, 0.25, 0.05})\n    network.GetNode(\"Cough\").SetCPT(\"Flu=no,Cold=yes,COVID=yes\", []methods.Probability{0.8, 0.15, 0.05})\n    network.GetNode(\"Cough\").SetCPT(\"Flu=no,Cold=yes,COVID=no\", []methods.Probability{0.6, 0.3, 0.1})\n    network.GetNode(\"Cough\").SetCPT(\"Flu=no,Cold=no,COVID=yes\", []methods.Probability{0.75, 0.2, 0.05})\n    network.GetNode(\"Cough\").SetCPT(\"Flu=no,Cold=no,COVID=no\", []methods.Probability{0.05, 0.15, 0.8})\n\n    // Similar setup for other symptoms...\n    setupRemainingCPTs(network)\n}\n\n// setupRemainingCPTs sets up CPTs for remaining symptoms\nfunc setupRemainingCPTs(network *bayesian_inference.BayesianNetwork) {\n    // Fatigue | Diseases\n    network.GetNode(\"Fatigue\").SetCPT(\"Flu=yes,Pneumonia=yes,COVID=yes\", []methods.Probability{0.95, 0.04, 0.01})\n    network.GetNode(\"Fatigue\").SetCPT(\"Flu=yes,Pneumonia=yes,COVID=no\", []methods.Probability{0.9, 0.08, 0.02})\n    network.GetNode(\"Fatigue\").SetCPT(\"Flu=yes,Pneumonia=no,COVID=yes\", []methods.Probability{0.85, 0.12, 0.03})\n    network.GetNode(\"Fatigue\").SetCPT(\"Flu=yes,Pneumonia=no,COVID=no\", []methods.Probability{0.7, 0.25, 0.05})\n    network.GetNode(\"Fatigue\").SetCPT(\"Flu=no,Pneumonia=yes,COVID=yes\", []methods.Probability{0.9, 0.08, 0.02})\n    network.GetNode(\"Fatigue\").SetCPT(\"Flu=no,Pneumonia=yes,COVID=no\", []methods.Probability{0.8, 0.15, 0.05})\n    network.GetNode(\"Fatigue\").SetCPT(\"Flu=no,Pneumonia=no,COVID=yes\", []methods.Probability{0.75, 0.2, 0.05})\n    network.GetNode(\"Fatigue\").SetCPT(\"Flu=no,Pneumonia=no,COVID=no\", []methods.Probability{0.1, 0.2, 0.7})\n\n    // Sore Throat | Diseases\n    network.GetNode(\"SoreThroat\").SetCPT(\"Flu=yes,Cold=yes\", []methods.Probability{0.8, 0.2})\n    network.GetNode(\"SoreThroat\").SetCPT(\"Flu=yes,Cold=no\", []methods.Probability{0.6, 0.4})\n    network.GetNode(\"SoreThroat\").SetCPT(\"Flu=no,Cold=yes\", []methods.Probability{0.7, 0.3})\n    network.GetNode(\"SoreThroat\").SetCPT(\"Flu=no,Cold=no\", []methods.Probability{0.1, 0.9})\n\n    // Shortness of Breath | Diseases\n    network.GetNode(\"ShortnessOfBreath\").SetCPT(\"Pneumonia=yes,COVID=yes\", []methods.Probability{0.9, 0.1})\n    network.GetNode(\"ShortnessOfBreath\").SetCPT(\"Pneumonia=yes,COVID=no\", []methods.Probability{0.8, 0.2})\n    network.GetNode(\"ShortnessOfBreath\").SetCPT(\"Pneumonia=no,COVID=yes\", []methods.Probability{0.7, 0.3})\n    network.GetNode(\"ShortnessOfBreath\").SetCPT(\"Pneumonia=no,COVID=no\", []methods.Probability{0.05, 0.95})\n\n    // Loss of Taste | COVID\n    network.GetNode(\"LossOfTaste\").SetCPT(\"yes\", []methods.Probability{0.8, 0.2})\n    network.GetNode(\"LossOfTaste\").SetCPT(\"no\", []methods.Probability{0.1, 0.9})\n}\n\n// =============================================================================\n// DEPLOYMENT AND ACCESS CONTROL\n// =============================================================================\n\n// Deploy initializes the diagnostic AI system\nfunc Deploy(caller string, ownerAddress string) string {\n    // Check if already deployed\n    if systemOwner != \"\" {\n        return \"Error: Diagnostic system already deployed\"\n    }\n\n    // Validate owner address\n    if !std.IsValidAddress(ownerAddress) {\n        return \"Error: Invalid owner address format\"\n    }\n\n    systemOwner = ownerAddress\n    authorizedDoctors = append(authorizedDoctors, ownerAddress)\n\n    std.Emit(\"DiagnosticSystemDeployed\", map[string]interface{}{\n        \"owner\": ownerAddress,\n        \"networkSize\": len(diagnosticNetwork.Nodes),\n        \"timestamp\": std.BlockTime(),\n    })\n\n    return \"Diagnostic AI system deployed successfully\"\n}\n\n// AuthorizeDoctor grants access to medical professionals\nfunc AuthorizeDoctor(caller string, doctorAddress string) string {\n    if caller != systemOwner {\n        return \"Access denied: only system owner can authorize doctors\"\n    }\n\n    if !std.IsValidAddress(doctorAddress) {\n        return \"Error: Invalid doctor address format\"\n    }\n\n    for _, doctor := range authorizedDoctors {\n        if doctor == doctorAddress {\n            return \"Doctor already authorized\"\n        }\n    }\n\n    authorizedDoctors = append(authorizedDoctors, doctorAddress)\n\n    std.Emit(\"DoctorAuthorized\", map[string]interface{}{\n        \"doctor\": doctorAddress,\n        \"authorizedBy\": caller,\n        \"timestamp\": std.BlockTime(),\n    })\n\n    return \"Doctor authorized successfully\"\n}\n\n// IsAuthorizedDoctor checks if a user is an authorized medical professional\nfunc IsAuthorizedDoctor(doctorAddress string) bool {\n    for _, doctor := range authorizedDoctors {\n        if doctor == doctorAddress {\n            return true\n        }\n    }\n    return false\n}\n\n// =============================================================================\n// CORE DIAGNOSTIC FUNCTIONS\n// =============================================================================\n\n// DiagnosePatient performs comprehensive diagnostic analysis\nfunc DiagnosePatient(caller string, patientID string, symptoms map[string]bool, testResults map[string]float64) string {\n    // Check authorization\n    if !IsAuthorizedDoctor(caller) {\n        return \"Access denied: only authorized doctors can perform diagnoses\"\n    }\n\n    // Validate inputs\n    if patientID == \"\" {\n        return \"Error: Patient ID cannot be empty\"\n    }\n\n    // Record timing and gas usage\n    startTime := std.BlockTime()\n    startGas := std.GasUsed()\n\n    // Convert symptoms and test results to evidence\n    evidence := make(map[string]string)\n\n    // Process fever based on temperature\n    if temp, exists := testResults[\"temperature\"]; exists {\n        if temp \u003e= 101.0 {\n            evidence[\"Fever\"] = \"high\"\n        } else if temp \u003e= 99.0 {\n            evidence[\"Fever\"] = \"moderate\"\n        } else {\n            evidence[\"Fever\"] = \"none\"\n        }\n    } else if symptoms[\"fever\"] {\n        evidence[\"Fever\"] = \"moderate\" // Assume moderate if reported but not measured\n    } else {\n        evidence[\"Fever\"] = \"none\"\n    }\n\n    // Process cough\n    if symptoms[\"cough\"] {\n        evidence[\"Cough\"] = \"severe\" // Assume severe if present\n    } else {\n        evidence[\"Cough\"] = \"none\"\n    }\n\n    // Process fatigue\n    if symptoms[\"fatigue\"] {\n        evidence[\"Fatigue\"] = \"severe\"\n    } else {\n        evidence[\"Fatigue\"] = \"none\"\n    }\n\n    // Process headache\n    if symptoms[\"headache\"] {\n        evidence[\"Headache\"] = \"severe\"\n    } else {\n        evidence[\"Headache\"] = \"none\"\n    }\n\n    // Process sore throat\n    if symptoms[\"soreThroat\"] {\n        evidence[\"SoreThroat\"] = \"yes\"\n    } else {\n        evidence[\"SoreThroat\"] = \"no\"\n    }\n\n    // Process shortness of breath\n    if symptoms[\"shortnessOfBreath\"] {\n        evidence[\"ShortnessOfBreath\"] = \"yes\"\n    } else {\n        evidence[\"ShortnessOfBreath\"] = \"no\"\n    }\n\n    // Process loss of taste/smell\n    if symptoms[\"lossOfTaste\"] || symptoms[\"lossOfSmell\"] {\n        evidence[\"LossOfTaste\"] = \"yes\"\n    } else {\n        evidence[\"LossOfTaste\"] = \"no\"\n    }\n\n    // Perform Bayesian inference\n    diagnosis := make(map[string]methods.Probability)\n    diseases := []string{\"Flu\", \"Cold\", \"Pneumonia\", \"Allergy\", \"COVID\"}\n\n    for _, disease := range diseases {\n        query := map[string]string{disease: \"\"}\n        result := inferenceEngine.Query(query, evidence)\n        diagnosis[disease] = result[\"yes\"]\n    }\n\n    // Calculate diagnostic confidence\n    confidence := calculateDiagnosticConfidence(diagnosis, evidence)\n\n    // Generate test recommendations\n    recommendations := generateTestRecommendations(diagnosis, evidence, testResults)\n\n    // Record diagnosis\n    endTime := std.BlockTime()\n    endGas := std.GasUsed()\n\n    diagnosisCase := DiagnosisCase{\n        PatientID:        patientID,\n        Timestamp:        startTime,\n        Symptoms:         symptoms,\n        TestResults:      testResults,\n        Diagnosis:        diagnosis,\n        Confidence:       confidence,\n        RecommendedTests: recommendations,\n        DoctorID:         caller,\n        GasUsed:          endGas - startGas,\n        ProcessingTime:   endTime - startTime,\n    }\n\n    // Manage history size\n    if len(diagnosisHistory) \u003e= maxHistorySize {\n        diagnosisHistory = diagnosisHistory[1:]\n    }\n    diagnosisHistory = append(diagnosisHistory, diagnosisCase)\n\n    // Update system metrics\n    updateSystemMetrics(diagnosisCase)\n\n    // Emit diagnosis event\n    std.Emit(\"DiagnosisCompleted\", map[string]interface{}{\n        \"patientID\": patientID,\n        \"doctor\": caller,\n        \"confidence\": confidence,\n        \"primaryDiagnosis\": getPrimaryDiagnosis(diagnosis),\n        \"gasUsed\": diagnosisCase.GasUsed,\n        \"processingTime\": diagnosisCase.ProcessingTime,\n        \"timestamp\": startTime,\n    })\n\n    // Format and return results\n    return formatDiagnosisResults(diagnosisCase)\n}\n\n// calculateDiagnosticConfidence computes overall confidence in diagnosis\nfunc calculateDiagnosticConfidence(diagnosis map[string]methods.Probability, evidence map[string]string) methods.Probability {\n    // Base confidence on evidence strength\n    evidenceCount := len(evidence)\n    evidenceStrength := methods.Probability(evidenceCount) / 7.0 // Normalize by max possible evidence\n\n    // Calculate probability spread (lower spread = higher confidence)\n    probs := make([]methods.Probability, 0, len(diagnosis))\n    for _, prob := range diagnosis {\n        probs = append(probs, prob)\n    }\n\n    // Find max probability\n    maxProb := methods.Probability(0)\n    for _, prob := range probs {\n        if prob \u003e maxProb {\n            maxProb = prob\n        }\n    }\n\n    // Calculate spread from max probability\n    spread := methods.Probability(0)\n    for _, prob := range probs {\n        spread += (maxProb - prob) * (maxProb - prob)\n    }\n    spread = methods.Probability(math.Sqrt(float64(spread) / float64(len(probs))))\n\n    // Lower spread = higher confidence\n    spreadConfidence := methods.Probability(1.0) / (methods.Probability(1.0) + spread)\n\n    // Combine factors\n    confidence := (evidenceStrength * 0.6) + (spreadConfidence * 0.4)\n\n    // Ensure reasonable bounds\n    if confidence \u003e 1.0 {\n        confidence = 1.0\n    } else if confidence \u003c 0.0 {\n        confidence = 0.0\n    }\n\n    return confidence\n}\n\n// generateTestRecommendations suggests additional diagnostic tests\nfunc generateTestRecommendations(diagnosis map[string]methods.Probability, evidence map[string]string, testResults map[string]float64) []string {\n    tests := make([]string, 0)\n\n    fluProb := diagnosis[\"Flu\"]\n    pneumoniaProb := diagnosis[\"Pneumonia\"]\n    covidProb := diagnosis[\"COVID\"]\n\n    // Temperature test\n    if _, hasTemp := testResults[\"temperature\"]; !hasTemp {\n        tests = append(tests, \"Temperature measurement\")\n    }\n\n    // Blood tests\n    if fluProb \u003e 0.3 || pneumoniaProb \u003e 0.2 {\n        tests = append(tests, \"Complete blood count (CBC)\")\n    }\n\n    // PCR tests for respiratory infections\n    if fluProb \u003e 0.4 {\n        tests = append(tests, \"Influenza PCR test\")\n    }\n    if covidProb \u003e 0.3 {\n        tests = append(tests, \"COVID-19 PCR test\")\n    }\n\n    // Imaging studies\n    if pneumoniaProb \u003e 0.3 {\n        tests = append(tests, \"Chest X-ray\")\n        tests = append(tests, \"CT chest scan\")\n    }\n\n    // Specialized tests\n    if covidProb \u003e 0.4 {\n        tests = append(tests, \"COVID-19 antibody test\")\n    }\n\n    return tests\n}\n\n// getPrimaryDiagnosis identifies the most likely diagnosis\nfunc getPrimaryDiagnosis(diagnosis map[string]methods.Probability) string {\n    maxProb := methods.Probability(0)\n    primary := \"Unknown\"\n\n    for disease, prob := range diagnosis {\n        if prob \u003e maxProb {\n            maxProb = prob\n            primary = disease\n        }\n    }\n\n    return primary\n}\n\n// formatDiagnosisResults creates a human-readable diagnosis report\nfunc formatDiagnosisResults(case DiagnosisCase) string {\n    result := \"🏥 AI Medical Diagnosis Report\\n\"\n    result += \"═══════════════════════════════════════════════\\n\\n\"\n\n    result += \"👤 Patient ID: \" + case.PatientID + \"\\n\"\n    result += ufmt.Sprintf(\"👨‍⚕️ Doctor: %s\\n\", case.DoctorID)\n    result += ufmt.Sprintf(\"📅 Diagnosis Time: %d\\n\", case.Timestamp)\n    result += ufmt.Sprintf(\"⚡ Processing Gas: %d\\n\\n\", case.GasUsed)\n\n    result += \"📊 Disease Probabilities:\\n\"\n    diseases := []string{\"Flu\", \"Cold\", \"Pneumonia\", \"Allergy\", \"COVID\"}\n\n    for _, disease := range diseases {\n        prob := case.Diagnosis[disease]\n        barWidth := int(prob * 30)\n        bar := \"\"\n        for i := 0; i \u003c barWidth; i++ {\n            bar += \"█\"\n        }\n        for i := barWidth; i \u003c 30; i++ {\n            bar += \"░\"\n        }\n\n        result += ufmt.Sprintf(\"   %s: %s %.1f%%\\n\", disease, bar, prob*100)\n    }\n\n    result += ufmt.Sprintf(\"\\n🎯 Diagnostic Confidence: %.1f%%\\n\", case.Confidence*100)\n\n    // Confidence interpretation\n    if case.Confidence \u003e 0.8 {\n        result += \"   🟢 HIGH CONFIDENCE: Strong evidence supports diagnosis\\n\"\n    } else if case.Confidence \u003e 0.6 {\n        result += \"   🟡 MODERATE CONFIDENCE: Reasonable evidence, consider additional tests\\n\"\n    } else {\n        result += \"   🔴 LOW CONFIDENCE: Limited evidence, additional testing recommended\\n\"\n    }\n\n    // Primary diagnosis\n    primary := getPrimaryDiagnosis(case.Diagnosis)\n    primaryProb := case.Diagnosis[primary]\n    result += ufmt.Sprintf(\"\\n🏆 Primary Diagnosis: %s (%.1f%% probability)\\n\", primary, primaryProb*100)\n\n    // Recommendations\n    if len(case.RecommendedTests) \u003e 0 {\n        result += \"\\n🧪 Recommended Additional Tests:\\n\"\n        for i, test := range case.RecommendedTests {\n            result += ufmt.Sprintf(\"   %d. %s\\n\", i+1, test)\n        }\n    }\n\n    // Clinical insights\n    result += \"\\n🧠 AI Clinical Insights:\\n\"\n    if primaryProb \u003e 0.7 {\n        result += \"   • High probability diagnosis - proceed with treatment\\n\"\n    } else if primaryProb \u003e 0.5 {\n        result += \"   • Moderate probability - consider differential diagnosis\\n\"\n    } else {\n        result += \"   • Low probability - broad differential diagnosis needed\\n\"\n    }\n\n    // Risk assessment\n    highRiskCount := 0\n    for _, prob := range case.Diagnosis {\n        if prob \u003e 0.3 {\n            highRiskCount++\n        }\n    }\n\n    if highRiskCount \u003e 2 {\n        result += \"   • Multiple differential diagnoses - comprehensive evaluation needed\\n\"\n    }\n\n    return result\n}\n\n// updateSystemMetrics updates overall system performance metrics\nfunc updateSystemMetrics(newCase DiagnosisCase) {\n    systemMetrics.TotalDiagnoses++\n\n    // Update average confidence\n    totalConfidence := systemMetrics.AverageConfidence * methods.Probability(systemMetrics.TotalDiagnoses-1)\n    totalConfidence += newCase.Confidence\n    systemMetrics.AverageConfidence = totalConfidence / methods.Probability(systemMetrics.TotalDiagnoses)\n\n    // Update most common disease\n    diseaseCounts := make(map[string]int)\n    for _, case := range diagnosisHistory {\n        primary := getPrimaryDiagnosis(case.Diagnosis)\n        diseaseCounts[primary]++\n    }\n\n    maxCount := 0\n    mostCommon := \"None\"\n    for disease, count := range diseaseCounts {\n        if count \u003e maxCount {\n            maxCount = count\n            mostCommon = disease\n        }\n    }\n    systemMetrics.MostCommonDisease = mostCommon\n\n    // Update gas metrics\n    totalGas := systemMetrics.AverageGasPerCase * uint64(systemMetrics.TotalDiagnoses-1)\n    totalGas += newCase.GasUsed\n    systemMetrics.AverageGasPerCase = totalGas / uint64(systemMetrics.TotalDiagnoses)\n\n    systemMetrics.LastUpdateTime = std.BlockTime()\n}\n\n// =============================================================================\n// MONITORING AND ANALYTICS\n// =============================================================================\n\n// GetSystemStatus returns comprehensive system status\nfunc GetSystemStatus(caller string) string {\n    if !IsAuthorizedDoctor(caller) {\n        return \"Access denied: only authorized doctors can view system status\"\n    }\n\n    status := \"🏥 Diagnostic AI System Status\\n\"\n    status += \"═══════════════════════════════════════════════\\n\\n\"\n\n    status += \"👑 System Owner: \" + systemOwner + \"\\n\"\n    status += ufmt.Sprintf(\"👨‍⚕️ Authorized Doctors: %d\\n\", len(authorizedDoctors))\n    status += ufmt.Sprintf(\"📊 Total Diagnoses: %d\\n\", systemMetrics.TotalDiagnoses)\n    status += ufmt.Sprintf(\"🎯 Average Confidence: %.1f%%\\n\", systemMetrics.AverageConfidence*100)\n    status += \"🏆 Most Common Diagnosis: \" + systemMetrics.MostCommonDisease + \"\\n\"\n    status += ufmt.Sprintf(\"⚡ Average Gas per Diagnosis: %d\\n\", systemMetrics.AverageGasPerCase)\n    status += ufmt.Sprintf(\"📚 Diagnosis History Size: %d/%d\\n\", len(diagnosisHistory), maxHistorySize)\n    status += ufmt.Sprintf(\"⏰ Last Update: %d\\n\\n\", systemMetrics.LastUpdateTime)\n\n    status += \"🧠 Bayesian Network Status:\\n\"\n    status += ufmt.Sprintf(\"   • Disease Nodes: 5\\n\")\n    status += ufmt.Sprintf(\"   • Symptom Nodes: 7\\n\")\n    status += ufmt.Sprintf(\"   • Total Nodes: %d\\n\", len(diagnosticNetwork.Nodes))\n    status += ufmt.Sprintf(\"   • Confidence Threshold: %.1f\\n\\n\", confidenceThreshold)\n\n    status += \"📈 Performance Assessment:\\n\"\n    if systemMetrics.AverageConfidence \u003e 0.8 {\n        status += \"   🟢 EXCELLENT: High diagnostic confidence across cases\\n\"\n    } else if systemMetrics.AverageConfidence \u003e 0.6 {\n        status += \"   🟡 GOOD: Moderate diagnostic confidence\\n\"\n    } else {\n        status += \"   🔴 NEEDS IMPROVEMENT: Low diagnostic confidence\\n\"\n    }\n\n    if systemMetrics.AverageGasPerCase \u003c 50000 {\n        status += \"   🟢 EFFICIENT: Gas usage is within acceptable limits\\n\"\n    } else {\n        status += \"   ⚠️  HIGH GAS USAGE: Consider optimization\\n\"\n    }\n\n    return status\n}\n\n// GetDiagnosisHistory returns recent diagnosis history\nfunc GetDiagnosisHistory(caller string, limit int) string {\n    if !IsAuthorizedDoctor(caller) {\n        return \"Access denied: only authorized doctors can view diagnosis history\"\n    }\n\n    if len(diagnosisHistory) == 0 {\n        return \"No diagnosis history available\"\n    }\n\n    if limit \u003c= 0 || limit \u003e len(diagnosisHistory) {\n        limit = len(diagnosisHistory)\n    }\n\n    history := ufmt.Sprintf(\"📚 Diagnosis History (Last %d cases):\\n\", limit)\n    history += \"═══════════════════════════════════════════════\\n\"\n\n    start := len(diagnosisHistory) - limit\n    if start \u003c 0 {\n        start = 0\n    }\n\n    for i := start; i \u003c len(diagnosisHistory); i++ {\n        case := diagnosisHistory[i]\n        history += ufmt.Sprintf(\"\\nCase %d: Patient %s\\n\", i+1, case.PatientID)\n        history += ufmt.Sprintf(\"   Time: %d\\n\", case.Timestamp)\n        history += ufmt.Sprintf(\"   Confidence: %.1f%%\\n\", case.Confidence*100)\n\n        primary := getPrimaryDiagnosis(case.Diagnosis)\n        primaryProb := case.Diagnosis[primary]\n        history += ufmt.Sprintf(\"   Primary Diagnosis: %s (%.1f%%)\\n\", primary, primaryProb*100)\n        history += ufmt.Sprintf(\"   Gas Used: %d\\n\", case.GasUsed)\n    }\n\n    return history\n}\n\n// AnalyzeDiagnosticPerformance provides detailed performance analysis\nfunc AnalyzeDiagnosticPerformance(caller string) string {\n    if !IsAuthorizedDoctor(caller) {\n        return \"Access denied: only authorized doctors can analyze performance\"\n    }\n\n    analysis := \"📊 Diagnostic Performance Analysis\\n\"\n    analysis += \"═══════════════════════════════════════════════\\n\\n\"\n\n    if len(diagnosisHistory) == 0 {\n        return analysis + \"No diagnosis data available for analysis\"\n    }\n\n    // Confidence distribution\n    highConfidence := 0\n    mediumConfidence := 0\n    lowConfidence := 0\n\n    for _, case := range diagnosisHistory {\n        if case.Confidence \u003e 0.8 {\n            highConfidence++\n        } else if case.Confidence \u003e 0.6 {\n            mediumConfidence++\n        } else {\n            lowConfidence++\n        }\n    }\n\n    analysis += \"🎯 Confidence Distribution:\\n\"\n    analysis += ufmt.Sprintf(\"   High (\u003e80%%): %d cases (%.1f%%)\\n\",\n        highConfidence, float64(highConfidence)/float64(len(diagnosisHistory))*100)\n    analysis += ufmt.Sprintf(\"   Medium (60-80%%): %d cases (%.1f%%)\\n\",\n        mediumConfidence, float64(mediumConfidence)/float64(len(diagnosisHistory))*100)\n    analysis += ufmt.Sprintf(\"   Low (\u003c60%%): %d cases (%.1f%%)\\n\\n\",\n        lowConfidence, float64(lowConfidence)/float64(len(diagnosisHistory))*100)\n\n    // Disease frequency analysis\n    diseaseFreq := make(map[string]int)\n    for _, case := range diagnosisHistory {\n        primary := getPrimaryDiagnosis(case.Diagnosis)\n        diseaseFreq[primary]++\n    }\n\n    analysis += \"🏥 Disease Frequency:\\n\"\n    diseases := []string{\"Flu\", \"Cold\", \"Pneumonia\", \"Allergy\", \"COVID\"}\n    for _, disease := range diseases {\n        count := diseaseFreq[disease]\n        percentage := float64(count) / float64(len(diagnosisHistory)) * 100\n        analysis += ufmt.Sprintf(\"   %s: %d cases (%.1f%%)\\n\", disease, count, percentage)\n    }\n\n    analysis += \"\\n💡 Recommendations:\\n\"\n    if float64(lowConfidence)/float64(len(diagnosisHistory)) \u003e 0.3 {\n        analysis += \"   • Consider improving evidence collection\\n\"\n        analysis += \"   • Review symptom assessment protocols\\n\"\n    }\n\n    mostCommon := \"\"\n    maxFreq := 0\n    for disease, freq := range diseaseFreq {\n        if freq \u003e maxFreq {\n            maxFreq = freq\n            mostCommon = disease\n        }\n    }\n\n    if maxFreq \u003e len(diagnosisHistory)/2 {\n        analysis += ufmt.Sprintf(\"   • High incidence of %s - consider public health measures\\n\", mostCommon)\n    }\n\n    return analysis\n}\n\n// =============================================================================\n// RENDER METHOD FOR BLOCKCHAIN QUERIES\n// =============================================================================\n\n// Render provides different views of the diagnostic system\nfunc Render(path string) string {\n    switch path {\n    case \"\":\n        return GetSystemStatus(\"\")\n    case \"status\":\n        return GetSystemStatus(\"\")\n    case \"metrics\":\n        return ufmt.Sprintf(`System Metrics:\nDiagnoses: %d\nAvg Confidence: %.1f%%\nMost Common: %s\nAvg Gas: %d`,\n            systemMetrics.TotalDiagnoses,\n            systemMetrics.AverageConfidence*100,\n            systemMetrics.MostCommonDisease,\n            systemMetrics.AverageGasPerCase)\n    case \"performance\":\n        return AnalyzeDiagnosticPerformance(\"\")\n    case \"history\":\n        return GetDiagnosisHistory(\"\", 5)\n    case \"network\":\n        return ufmt.Sprintf(\"Bayesian Network: %d nodes, %d diagnoses completed\",\n            len(diagnosticNetwork.Nodes), len(diagnosisHistory))\n    default:\n        return \"Unknown path: \" + path + \". Try: status, metrics, performance, history, network\"\n    }\n}\n\n"},{"name":"gno.mod","body":"module gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/diagnostic_ai\n\ngno 0.9\n"}],"type":{"@type":"/gno.MemPackageType","value":"MPUserAll"},"info":null},"send":""}],"fee":{"gas_wanted":"10000000","gas_fee":"10000000ugnot"},"signatures":null,"memo":""}
