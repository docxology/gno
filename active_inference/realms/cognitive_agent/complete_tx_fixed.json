{"msg":[{"@type":"/vm.m_addpkg","creator":"g155vatadknr3gdq9pq6va8q4jk6gu4znklkjkce","package":{"name":"cognitive_agent","path":"gno.land/r/g155vatadknr3gdq9pq6va8q4jk6gu4znklkjkce/cognitive_agent","files":[{"name":"cognitive_agent.gno","body":"// Package cognitive_agent provides a deployable Active Inference agent realm\n// for the Gno blockchain. This realm implements a complete cognitive agent\n// capable of perception, planning, action, and learning.\npackage cognitive_agent\n\nimport (\n    \"gno.land/p/active_inference/methods/active_inference_core\"\n    \"gno.land/p/active_inference/methods\"\n    \"std\"\n    \"gno.land/p/nt/ufmt\"\n    \"math\"\n)\n\n// =============================================================================\n// GLOBAL STATE - PERSISTED ACROSS TRANSACTIONS\n// =============================================================================\n\n// Core agent instance - the heart of our cognitive system\nvar agent *active_inference_core.ActiveInferenceAgent\n\n// Access control\nvar owner string\nvar authorizedUsers []string\n\n// History and analytics\nvar observationHistory []ObservationRecord\nvar decisionHistory []DecisionRecord\nvar learningHistory []LearningRecord\n\n// Performance metrics\nvar totalObservations int64\nvar totalDecisions int64\nvar averageBeliefAccuracy methods.Probability\nvar totalGasUsed uint64\n\n// Configuration\nvar maxHistorySize int\nvar gasCheckpoint uint64\n\n// =============================================================================\n// DATA STRUCTURES\n// =============================================================================\n\n// ObservationRecord tracks environmental observations\ntype ObservationRecord struct {\n    Timestamp   int64\n    Data        []methods.Probability\n    Source      string\n    GasUsed     uint64\n}\n\n// DecisionRecord tracks agent decisions and actions\ntype DecisionRecord struct {\n    Timestamp   int64\n    Observation []methods.Probability\n    Policies    []PolicyInfo\n    ActionTaken int\n    Confidence  methods.Probability\n    GasUsed     uint64\n}\n\n// PolicyInfo contains information about generated policies\ntype PolicyInfo struct {\n    Actions     []methods.Probability\n    ExpectedUtility methods.Probability\n    Complexity  int\n}\n\n// LearningRecord tracks learning episodes\ntype LearningRecord struct {\n    Timestamp     int64\n    Reward        methods.Probability\n    BeliefAccuracyBefore methods.Probability\n    BeliefAccuracyAfter methods.Probability\n    GasUsed       uint64\n}\n\n// =============================================================================\n// REALM INITIALIZATION\n// =============================================================================\n\n// init is called when the realm is deployed to the blockchain\nfunc init() {\n    // Initialize the cognitive agent\n    agent = active_inference_core.NewActiveInferenceAgent()\n\n    // Initialize access control\n    owner = \"\"\n    authorizedUsers = make([]string, 0)\n\n    // Initialize history arrays\n    observationHistory = make([]ObservationRecord, 0)\n    decisionHistory = make([]DecisionRecord, 0)\n    learningHistory = make([]LearningRecord, 0)\n\n    // Initialize metrics\n    totalObservations = 0\n    totalDecisions = 0\n    averageBeliefAccuracy = 0.5\n    totalGasUsed = 0\n\n    // Set configuration\n    maxHistorySize = 100\n\n    // Record gas usage for initialization\n    gasCheckpoint = std.GasUsed()\n\n    // Emit initialization event\n    std.Emit(\"RealmInitialized\", map[string]interface{}{\n        \"timestamp\": std.BlockTime(),\n        \"agentType\": \"ActiveInference\",\n        \"maxHistorySize\": maxHistorySize,\n    })\n}\n\n// =============================================================================\n// DEPLOYMENT AND ACCESS CONTROL\n// =============================================================================\n\n// Deploy initializes the cognitive agent realm for a specific owner\nfunc Deploy(caller string, ownerAddress string) string {\n    // Check if already deployed\n    if owner != \"\" {\n        return \"Error: Agent already deployed to address \" + owner\n    }\n\n    // Validate owner address\n    if !std.IsValidAddress(ownerAddress) {\n        return \"Error: Invalid owner address format\"\n    }\n\n    // Set owner and add to authorized users\n    owner = ownerAddress\n    authorizedUsers = append(authorizedUsers, ownerAddress)\n\n    // Record gas usage\n    gasUsed := std.GasUsed() - gasCheckpoint\n    totalGasUsed += gasUsed\n    gasCheckpoint = std.GasUsed()\n\n    // Emit deployment event\n    std.Emit(\"AgentDeployed\", map[string]interface{}{\n        \"owner\": ownerAddress,\n        \"caller\": caller,\n        \"gasUsed\": gasUsed,\n        \"timestamp\": std.BlockTime(),\n    })\n\n    return \"Cognitive agent deployed successfully to \" + ownerAddress\n}\n\n// AuthorizeUser grants access to additional users\nfunc AuthorizeUser(caller string, userAddress string) string {\n    // Only owner can authorize users\n    if caller != owner {\n        return \"Access denied: only owner can authorize users\"\n    }\n\n    // Validate address\n    if !std.IsValidAddress(userAddress) {\n        return \"Error: Invalid user address format\"\n    }\n\n    // Check if already authorized\n    for _, user := range authorizedUsers {\n        if user == userAddress {\n            return \"User \" + userAddress + \" is already authorized\"\n        }\n    }\n\n    // Add to authorized users\n    authorizedUsers = append(authorizedUsers, userAddress)\n\n    // Emit authorization event\n    std.Emit(\"UserAuthorized\", map[string]interface{}{\n        \"user\": userAddress,\n        \"authorizedBy\": caller,\n        \"timestamp\": std.BlockTime(),\n    })\n\n    return \"User \" + userAddress + \" authorized successfully\"\n}\n\n// IsAuthorized checks if a user has access to the agent\nfunc IsAuthorized(userAddress string) bool {\n    for _, authorized := range authorizedUsers {\n        if authorized == userAddress {\n            return true\n        }\n    }\n    return false\n}\n\n// =============================================================================\n// CORE COGNITIVE FUNCTIONS\n// =============================================================================\n\n// ProcessObservation processes environmental observations and updates agent state\nfunc ProcessObservation(caller string, observation []methods.Probability, source string) string {\n    // Check authorization\n    if !IsAuthorized(caller) {\n        return \"Access denied: user not authorized\"\n    }\n\n    // Validate observation\n    if len(observation) == 0 {\n        return \"Error: Empty observation\"\n    }\n\n    // Validate probability values\n    for i, prob := range observation {\n        if prob \u003c 0 || prob \u003e 1 {\n            return ufmt.Sprintf(\"Error: Invalid probability at index %d: %f (must be between 0 and 1)\", i, prob)\n        }\n    }\n\n    // Record gas usage start\n    gasStart := std.GasUsed()\n\n    // Process observation with the agent\n    err := agent.Perceive(observation)\n    if err != nil {\n        return \"Error processing observation: \" + err.Error()\n    }\n\n    // Generate action plan\n    policies, err := agent.Plan()\n    if err != nil {\n        return \"Error generating plan: \" + err.Error()\n    }\n\n    // Record observation\n    obsRecord := ObservationRecord{\n        Timestamp: std.BlockTime(),\n        Data:      observation,\n        Source:    source,\n        GasUsed:   0, // Will be set below\n    }\n\n    // Manage history size\n    if len(observationHistory) \u003e= maxHistorySize {\n        // Remove oldest observation (circular buffer)\n        observationHistory = observationHistory[1:]\n    }\n    observationHistory = append(observationHistory, obsRecord)\n\n    // Update metrics\n    totalObservations++\n\n    // Calculate gas used\n    gasUsed := std.GasUsed() - gasStart\n    totalGasUsed += gasUsed\n    obsRecord.GasUsed = gasUsed\n    observationHistory[len(observationHistory)-1] = obsRecord\n\n    // Emit observation event\n    std.Emit(\"ObservationProcessed\", map[string]interface{}{\n        \"caller\": caller,\n        \"observationLength\": len(observation),\n        \"source\": source,\n        \"policiesGenerated\": len(policies),\n        \"gasUsed\": gasUsed,\n        \"timestamp\": std.BlockTime(),\n    })\n\n    // Return success message\n    return ufmt.Sprintf(\"Observation processed successfully. Generated %d policies. Gas used: %d\",\n        len(policies), gasUsed)\n}\n\n// ExecuteAction executes the specified action policy\nfunc ExecuteAction(caller string, policyIndex int) string {\n    // Check authorization\n    if !IsAuthorized(caller) {\n        return \"Access denied: user not authorized\"\n    }\n\n    // Validate policy index\n    if policyIndex \u003c 0 {\n        return \"Error: Policy index cannot be negative\"\n    }\n\n    // Record gas usage start\n    gasStart := std.GasUsed()\n\n    // Execute action\n    err := agent.Act(policyIndex)\n    if err != nil {\n        return \"Error executing action: \" + err.Error()\n    }\n\n    // Get current policies for recording\n    policies, err := agent.Plan()\n    if err != nil {\n        return \"Error retrieving policies: \" + err.Error()\n    }\n\n    // Validate policy index against available policies\n    if policyIndex \u003e= len(policies) {\n        return ufmt.Sprintf(\"Error: Policy index %d out of range (available: 0-%d)\",\n            policyIndex, len(policies)-1)\n    }\n\n    // Record decision\n    policy := policies[policyIndex]\n    decisionRecord := DecisionRecord{\n        Timestamp:   std.BlockTime(),\n        Observation: agent.CurrentObservation,\n        Policies:    make([]PolicyInfo, len(policies)),\n        ActionTaken: policyIndex,\n        Confidence:  methods.Probability(0.8), // Simplified confidence calculation\n        GasUsed:     0, // Will be set below\n    }\n\n    // Convert policies to PolicyInfo\n    for i, p := range policies {\n        decisionRecord.Policies[i] = PolicyInfo{\n            Actions:          p.Actions,\n            ExpectedUtility:  methods.Probability(0.5 + 0.1*float64(i)), // Simplified utility\n            Complexity:       len(p.Actions),\n        }\n    }\n\n    // Manage history size\n    if len(decisionHistory) \u003e= maxHistorySize {\n        decisionHistory = decisionHistory[1:]\n    }\n    decisionHistory = append(decisionHistory, decisionRecord)\n\n    // Update metrics\n    totalDecisions++\n\n    // Calculate gas used\n    gasUsed := std.GasUsed() - gasStart\n    totalGasUsed += gasUsed\n    decisionRecord.GasUsed = gasUsed\n    decisionHistory[len(decisionHistory)-1] = decisionRecord\n\n    // Emit action event\n    std.Emit(\"ActionExecuted\", map[string]interface{}{\n        \"caller\": caller,\n        \"policyIndex\": policyIndex,\n        \"gasUsed\": gasUsed,\n        \"timestamp\": std.BlockTime(),\n    })\n\n    return ufmt.Sprintf(\"Action executed successfully. Policy %d selected. Gas used: %d\",\n        policyIndex, gasUsed)\n}\n\n// LearnFromFeedback updates the agent based on environmental feedback\nfunc LearnFromFeedback(caller string, reward methods.Probability) string {\n    // Check authorization\n    if !IsAuthorized(caller) {\n        return \"Access denied: user not authorized\"\n    }\n\n    // Validate reward\n    if reward \u003c -1 || reward \u003e 1 {\n        return ufmt.Sprintf(\"Error: Reward %f must be between -1 and 1\", reward)\n    }\n\n    // Record gas usage start\n    gasStart := std.GasUsed()\n\n    // Get belief accuracy before learning\n    accuracyBefore := agent.GetBeliefAccuracy()\n\n    // Perform learning\n    err := agent.Learn(reward)\n    if err != nil {\n        return \"Error during learning: \" + err.Error()\n    }\n\n    // Get belief accuracy after learning\n    accuracyAfter := agent.GetBeliefAccuracy()\n\n    // Update average accuracy\n    if totalObservations \u003e 0 {\n        averageBeliefAccuracy = (averageBeliefAccuracy*methods.Probability(totalObservations-1) + accuracyAfter) / methods.Probability(totalObservations)\n    } else {\n        averageBeliefAccuracy = accuracyAfter\n    }\n\n    // Record learning episode\n    learningRecord := LearningRecord{\n        Timestamp:           std.BlockTime(),\n        Reward:              reward,\n        BeliefAccuracyBefore: accuracyBefore,\n        BeliefAccuracyAfter:  accuracyAfter,\n        GasUsed:             0, // Will be set below\n    }\n\n    // Manage history size\n    if len(learningHistory) \u003e= maxHistorySize {\n        learningHistory = learningHistory[1:]\n    }\n    learningHistory = append(learningHistory, learningRecord)\n\n    // Calculate gas used\n    gasUsed := std.GasUsed() - gasStart\n    totalGasUsed += gasUsed\n    learningRecord.GasUsed = gasUsed\n    learningHistory[len(learningHistory)-1] = learningRecord\n\n    // Emit learning event\n    std.Emit(\"LearningCompleted\", map[string]interface{}{\n        \"caller\": caller,\n        \"reward\": reward,\n        \"accuracyBefore\": accuracyBefore,\n        \"accuracyAfter\": accuracyAfter,\n        \"gasUsed\": gasUsed,\n        \"timestamp\": std.BlockTime(),\n    })\n\n    return ufmt.Sprintf(\"Learning completed. Reward: %.3f, Accuracy improved: %.3f -\u003e %.3f, Gas used: %d\",\n        reward, accuracyBefore, accuracyAfter, gasUsed)\n}\n\n// =============================================================================\n// MONITORING AND ANALYTICS\n// =============================================================================\n\n// GetAgentStatus returns comprehensive agent status information\nfunc GetAgentStatus(caller string) string {\n    // Check authorization\n    if !IsAuthorized(caller) {\n        return \"Access denied: user not authorized\"\n    }\n\n    // Get current beliefs\n    beliefs := agent.CurrentBeliefs\n\n    // Calculate belief statistics\n    beliefStats := calculateBeliefStatistics(beliefs)\n\n    // Format status report\n    status := \"ü§ñ Cognitive Agent Status Report\\n\"\n    status += \"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\\n\\n\"\n\n    status += \"üë§ Owner: \" + owner + \"\\n\"\n    status += ufmt.Sprintf(\"‚è∞ Current Block: %d\\n\", std.BlockTime())\n    status += ufmt.Sprintf(\"üìä Total Observations: %d\\n\", totalObservations)\n    status += ufmt.Sprintf(\"üéØ Total Decisions: %d\\n\", totalDecisions)\n    status += ufmt.Sprintf(\"‚ö° Total Gas Used: %d\\n\\n\", totalGasUsed)\n\n    status += \"üß† Current Beliefs:\\n\"\n    for i, belief := range beliefs {\n        status += ufmt.Sprintf(\"  B%d: %.4f\\n\", i, belief)\n    }\n    status += \"\\n\"\n\n    status += \"üìà Belief Statistics:\\n\"\n    status += ufmt.Sprintf(\"  Average: %.4f\\n\", beliefStats.average)\n    status += ufmt.Sprintf(\"  Maximum: %.4f (B%d)\\n\", beliefStats.max, beliefStats.maxIndex)\n    status += ufmt.Sprintf(\"  Minimum: %.4f (B%d)\\n\", beliefStats.min, beliefStats.minIndex)\n    status += ufmt.Sprintf(\"  Entropy: %.4f\\n\", beliefStats.entropy)\n    status += \"\\n\"\n\n    status += ufmt.Sprintf(\"üéØ Average Belief Accuracy: %.4f\\n\", averageBeliefAccuracy)\n    status += ufmt.Sprintf(\"üìö History Size: %d/%d\\n\", len(observationHistory), maxHistorySize)\n    status += ufmt.Sprintf(\"üë• Authorized Users: %d\\n\", len(authorizedUsers))\n\n    // Performance assessment\n    status += \"\\nüìä Performance Assessment:\\n\"\n    if averageBeliefAccuracy \u003e 0.8 {\n        status += \"  üü¢ EXCELLENT: High belief accuracy indicates strong learning\\n\"\n    } else if averageBeliefAccuracy \u003e 0.6 {\n        status += \"  üü° GOOD: Moderate belief accuracy with room for improvement\\n\"\n    } else {\n        status += \"  üî¥ NEEDS IMPROVEMENT: Low belief accuracy suggests learning challenges\\n\"\n    }\n\n    if beliefStats.entropy \u003e 1.0 {\n        status += \"  üé≤ HIGH UNCERTAINTY: Agent has diverse beliefs - more observations needed\\n\"\n    } else if beliefStats.entropy \u003c 0.5 {\n        status += \"  üéØ LOW UNCERTAINTY: Agent has confident beliefs\\n\"\n    }\n\n    return status\n}\n\n// calculateBeliefStatistics computes statistics about current beliefs\nfunc calculateBeliefStatistics(beliefs []methods.Probability) BeliefStatistics {\n    if len(beliefs) == 0 {\n        return BeliefStatistics{}\n    }\n\n    stats := BeliefStatistics{\n        average: 0,\n        max: beliefs[0],\n        min: beliefs[0],\n        maxIndex: 0,\n        minIndex: 0,\n        entropy: 0,\n    }\n\n    // Calculate sum for average\n    sum := methods.Probability(0)\n    for i, belief := range beliefs {\n        sum += belief\n\n        // Track max\n        if belief \u003e stats.max {\n            stats.max = belief\n            stats.maxIndex = i\n        }\n\n        // Track min\n        if belief \u003c stats.min {\n            stats.min = belief\n            stats.minIndex = i\n        }\n    }\n\n    stats.average = sum / methods.Probability(len(beliefs))\n\n    // Calculate entropy\n    for _, belief := range beliefs {\n        if belief \u003e 0 {\n            stats.entropy -= belief * methods.Probability(math.Log(float64(belief)))\n        }\n    }\n\n    return stats\n}\n\n// BeliefStatistics contains statistical information about beliefs\ntype BeliefStatistics struct {\n    average  methods.Probability\n    max      methods.Probability\n    min      methods.Probability\n    maxIndex int\n    minIndex int\n    entropy  methods.Probability\n}\n\n// GetObservationHistory returns recent observation history\nfunc GetObservationHistory(caller string, limit int) string {\n    // Check authorization\n    if !IsAuthorized(caller) {\n        return \"Access denied: user not authorized\"\n    }\n\n    if len(observationHistory) == 0 {\n        return \"No observation history available\"\n    }\n\n    // Limit the number of records returned\n    if limit \u003c= 0 || limit \u003e len(observationHistory) {\n        limit = len(observationHistory)\n    }\n\n    history := ufmt.Sprintf(\"üìö Observation History (Last %d records):\\n\", limit)\n    history += \"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\\n\"\n\n    start := len(observationHistory) - limit\n    if start \u003c 0 {\n        start = 0\n    }\n\n    for i := start; i \u003c len(observationHistory); i++ {\n        record := observationHistory[i]\n        history += ufmt.Sprintf(\"\\n%d. Time: %d\\n\", i+1, record.Timestamp)\n        history += ufmt.Sprintf(\"   Source: %s\\n\", record.Source)\n        history += ufmt.Sprintf(\"   Data: [\", record.Data)\n        for j, value := range record.Data {\n            if j \u003e 0 {\n                history += \", \"\n            }\n            history += ufmt.Sprintf(\"%.3f\", value)\n        }\n        history += \"]\\n\"\n        history += ufmt.Sprintf(\"   Gas Used: %d\\n\", record.GasUsed)\n    }\n\n    return history\n}\n\n// GetDecisionHistory returns recent decision history\nfunc GetDecisionHistory(caller string, limit int) string {\n    // Check authorization\n    if !IsAuthorized(caller) {\n        return \"Access denied: user not authorized\"\n    }\n\n    if len(decisionHistory) == 0 {\n        return \"No decision history available\"\n    }\n\n    // Limit the number of records returned\n    if limit \u003c= 0 || limit \u003e len(decisionHistory) {\n        limit = len(decisionHistory)\n    }\n\n    history := ufmt.Sprintf(\"üéØ Decision History (Last %d records):\\n\", limit)\n    history += \"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\\n\"\n\n    start := len(decisionHistory) - limit\n    if start \u003c 0 {\n        start = 0\n    }\n\n    for i := start; i \u003c len(decisionHistory); i++ {\n        record := decisionHistory[i]\n        history += ufmt.Sprintf(\"\\n%d. Time: %d\\n\", i+1, record.Timestamp)\n        history += ufmt.Sprintf(\"   Action Taken: Policy %d\\n\", record.ActionTaken)\n        history += ufmt.Sprintf(\"   Confidence: %.3f\\n\", record.Confidence)\n        history += ufmt.Sprintf(\"   Policies Available: %d\\n\", len(record.Policies))\n        history += ufmt.Sprintf(\"   Gas Used: %d\\n\", record.GasUsed)\n    }\n\n    return history\n}\n\n// GetLearningHistory returns recent learning history\nfunc GetLearningHistory(caller string, limit int) string {\n    // Check authorization\n    if !IsAuthorized(caller) {\n        return \"Access denied: user not authorized\"\n    }\n\n    if len(learningHistory) == 0 {\n        return \"No learning history available\"\n    }\n\n    // Limit the number of records returned\n    if limit \u003c= 0 || limit \u003e len(learningHistory) {\n        limit = len(learningHistory)\n    }\n\n    history := ufmt.Sprintf(\"üß† Learning History (Last %d records):\\n\", limit)\n    history += \"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\\n\"\n\n    start := len(learningHistory) - limit\n    if start \u003c 0 {\n        start = 0\n    }\n\n    for i := start; i \u003c len(learningHistory); i++ {\n        record := learningHistory[i]\n        history += ufmt.Sprintf(\"\\n%d. Time: %d\\n\", i+1, record.Timestamp)\n        history += ufmt.Sprintf(\"   Reward: %.3f\\n\", record.Reward)\n        history += ufmt.Sprintf(\"   Accuracy Before: %.3f\\n\", record.BeliefAccuracyBefore)\n        history += ufmt.Sprintf(\"   Accuracy After: %.3f\\n\", record.BeliefAccuracyAfter)\n        history += ufmt.Sprintf(\"   Improvement: %.3f\\n\", record.BeliefAccuracyAfter-record.BeliefAccuracyBefore)\n        history += ufmt.Sprintf(\"   Gas Used: %d\\n\", record.GasUsed)\n    }\n\n    return history\n}\n\n// =============================================================================\n// ADVANCED ANALYTICS\n// =============================================================================\n\n// AnalyzePerformance provides detailed performance analysis\nfunc AnalyzePerformance(caller string) string {\n    // Check authorization\n    if !IsAuthorized(caller) {\n        return \"Access denied: user not authorized\"\n    }\n\n    analysis := \"üìä Performance Analysis Report\\n\"\n    analysis += \"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\\n\\n\"\n\n    // Basic metrics\n    analysis += \"üìà Basic Metrics:\\n\"\n    analysis += ufmt.Sprintf(\"   Total Observations: %d\\n\", totalObservations)\n    analysis += ufmt.Sprintf(\"   Total Decisions: %d\\n\", totalDecisions)\n    analysis += ufmt.Sprintf(\"   Total Learning Episodes: %d\\n\", len(learningHistory))\n    analysis += ufmt.Sprintf(\"   Average Belief Accuracy: %.4f\\n\", averageBeliefAccuracy)\n    analysis += ufmt.Sprintf(\"   Total Gas Used: %d\\n\\n\", totalGasUsed)\n\n    // Learning effectiveness\n    if len(learningHistory) \u003e 0 {\n        analysis += \"üß† Learning Effectiveness:\\n\"\n\n        totalImprovement := methods.Probability(0)\n        positiveLearning := 0\n        negativeLearning := 0\n\n        for _, record := range learningHistory {\n            improvement := record.BeliefAccuracyAfter - record.BeliefAccuracyBefore\n            totalImprovement += improvement\n\n            if improvement \u003e 0 {\n                positiveLearning++\n            } else if improvement \u003c 0 {\n                negativeLearning++\n            }\n        }\n\n        averageImprovement := totalImprovement / methods.Probability(len(learningHistory))\n        learningRate := methods.Probability(positiveLearning) / methods.Probability(len(learningHistory))\n\n        analysis += ufmt.Sprintf(\"   Average Improvement: %.4f\\n\", averageImprovement)\n        analysis += ufmt.Sprintf(\"   Learning Rate: %.1f%%\\n\", learningRate*100)\n        analysis += ufmt.Sprintf(\"   Positive Learning: %d\\n\", positiveLearning)\n        analysis += ufmt.Sprintf(\"   Negative Learning: %d\\n\\n\", negativeLearning)\n    }\n\n    // Gas efficiency\n    analysis += \"‚ö° Gas Efficiency:\\n\"\n    if totalObservations \u003e 0 {\n        avgGasPerObservation := float64(totalGasUsed) / float64(totalObservations)\n        analysis += ufmt.Sprintf(\"   Average Gas per Observation: %.0f\\n\", avgGasPerObservation)\n    }\n    if totalDecisions \u003e 0 {\n        avgGasPerDecision := float64(totalGasUsed) / float64(totalDecisions)\n        analysis += ufmt.Sprintf(\"   Average Gas per Decision: %.0f\\n\", avgGasPerDecision)\n    }\n    if len(learningHistory) \u003e 0 {\n        avgGasPerLearning := float64(totalGasUsed) / float64(len(learningHistory))\n        analysis += ufmt.Sprintf(\"   Average Gas per Learning: %.0f\\n\\n\", avgGasPerLearning)\n    }\n\n    // Recommendations\n    analysis += \"üí° Recommendations:\\n\"\n    if averageBeliefAccuracy \u003c 0.6 {\n        analysis += \"   ‚Ä¢ Consider providing more diverse observations\\n\"\n        analysis += \"   ‚Ä¢ Review reward structure for learning effectiveness\\n\"\n    }\n    if len(observationHistory) \u003e maxHistorySize/2 {\n        analysis += \"   ‚Ä¢ History is filling up - consider increasing maxHistorySize\\n\"\n    }\n    if totalGasUsed \u003e 1000000 {\n        analysis += \"   ‚Ä¢ High gas usage - consider optimization techniques\\n\"\n    }\n\n    return analysis\n}\n\n// ResetAgent resets the agent state (for testing/development)\nfunc ResetAgent(caller string) string {\n    // Only owner can reset\n    if caller != owner {\n        return \"Access denied: only owner can reset agent\"\n    }\n\n    // Reinitialize agent\n    agent = active_inference_core.NewActiveInferenceAgent()\n\n    // Clear history\n    observationHistory = make([]ObservationRecord, 0)\n    decisionHistory = make([]DecisionRecord, 0)\n    learningHistory = make([]LearningRecord, 0)\n\n    // Reset metrics\n    totalObservations = 0\n    totalDecisions = 0\n    averageBeliefAccuracy = 0.5\n    totalGasUsed = 0\n\n    // Emit reset event\n    std.Emit(\"AgentReset\", map[string]interface{}{\n        \"resetBy\": caller,\n        \"timestamp\": std.BlockTime(),\n    })\n\n    return \"Agent reset successfully\"\n}\n\n// =============================================================================\n// RENDER METHOD FOR BLOCKCHAIN QUERIES\n// =============================================================================\n\n// Render provides different views of the agent state for blockchain queries\nfunc Render(path string) string {\n    switch path {\n    case \"\":\n        return GetAgentStatus(\"\")\n    case \"status\":\n        return GetAgentStatus(\"\")\n    case \"beliefs\":\n        beliefs := agent.CurrentBeliefs\n        result := \"Current Beliefs: [\"\n        for i, belief := range beliefs {\n            if i \u003e 0 {\n                result += \", \"\n            }\n            result += ufmt.Sprintf(\"%.3f\", belief)\n        }\n        result += \"]\"\n        return result\n    case \"metrics\":\n        return ufmt.Sprintf(\"Observations: %d, Decisions: %d, Avg Accuracy: %.3f, Gas Used: %d\",\n            totalObservations, totalDecisions, averageBeliefAccuracy, totalGasUsed)\n    case \"performance\":\n        return AnalyzePerformance(\"\")\n    case \"history\":\n        return GetObservationHistory(\"\", 5)\n    case \"owner\":\n        return \"Owner: \" + owner\n    default:\n        return \"Unknown path: \" + path + \". Try: status, beliefs, metrics, performance, history, owner\"\n    }\n}\n\n// =============================================================================\n// UTILITY FUNCTIONS\n// =============================================================================\n\n// ValidateObservation checks if an observation is valid\nfunc ValidateObservation(observation []methods.Probability) error {\n    if len(observation) == 0 {\n        return ufmt.Errorf(\"empty observation\")\n    }\n\n    for i, prob := range observation {\n        if prob \u003c 0 || prob \u003e 1 {\n            return ufmt.Errorf(\"invalid probability at index %d: %f (must be between 0 and 1)\", i, prob)\n        }\n    }\n\n    return nil\n}\n\n// GetGasEstimate provides gas estimation for operations\nfunc GetGasEstimate(operation string) uint64 {\n    // Simplified gas estimation - in production, this would be more sophisticated\n    switch operation {\n    case \"perceive\":\n        return 2000\n    case \"plan\":\n        return 3000\n    case \"act\":\n        return 1500\n    case \"learn\":\n        return 2500\n    case \"analyze\":\n        return 1000\n    default:\n        return 1000\n    }\n}\n\n          },\n          {\n            \"name\": \"gno.mod\",\n            \"body\": \"module gno.land/r/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5/cognitive_agent\\n\"\n          }\n        ],\n        \"type\": {\n          \"@type\": \"/gno.MemPackageType\",\n          \"value\": \"MPUserAll\"\n        },\n        \"info\": null\n      },\n      \"send\": \"\"\n    }\n  ],\n  \"fee\": {\n    \"gas_wanted\": \"8000000\",\n    \"gas_fee\": \"10000000ugnot\"\n  },\n  \"signatures\": [\n    {\n      \"pub_key\": {\n        \"@type\": \"/tm.PubKeySecp256k1\",\n        \"value\": \"AucKuPC+tJEDe4wZYqXeZl+fwHkEt+s6/sjUsOB45xAo\"\n      },\n      \"signature\": \"jY+LL0rpLkR/DBBiH4L6UsqT1tTbsPaf0mxijXSs079oWDX4GdKgFLmQyerznPvfgek7nm1EjmT5ka+ojnzGNA==\"\n    }\n  ],\n  \"memo\": \"\"\n}
